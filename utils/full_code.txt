File add.cpp:

int add(int aaa, int bbb) { return aaa + bbb; }

int mul(int aaa, int bbb) { return aaa * bbb; }
File add.h:

#pragma once

int add(int a, int b);
int mul(int a, int b);
File diagnostic.cpp:

#include "diagnostic.h"

Diagnostic::Diagnostic(Level level, const std::string &message) : level(level), message(message) {}

void Diagnostic::addLabel(const Span &span, const std::string &labelMessage)
{
    labels.emplace_back(span, labelMessage);
}

Diagnostic::Level Diagnostic::getLevel() const { return level; }

const std::string &Diagnostic::getMessage() const { return message; }

const std::vector<std::pair<Span, std::string>> &Diagnostic::getLabels() const { return labels; }

File diagnostic.h:

#pragma once

#include <string>
#include <vector>
#include <memory>

#include "span.h"

class Diagnostic {
public:
    enum class Level { Error, Warning, Note };

    Diagnostic(Level level, const std::string &message);

    void addLabel(const Span &span, const std::string &labelMessage);

    Level getLevel() const;
    const std::string &getMessage() const;
    const std::vector<std::pair<Span, std::string>> &getLabels() const;

private:
    Level level;
    std::string message;
    std::vector<std::pair<Span, std::string>> labels;
};

File diag_ctxt.cpp:

#include "diag_ctxt.h"
#include "emitter.h"

DiagCtxt::DiagCtxt(std::shared_ptr<Emitter> emitter) : emitter(std::move(emitter)) {}

void DiagCtxt::addDiagnostic(const Diagnostic &diag) { diagnostics.push_back(diag); }

bool DiagCtxt::hasErrors() const { return !diagnostics.empty(); }

void DiagCtxt::emitDiagnostics()
{
    for (const auto &diag : diagnostics) {
        emitter->emit(diag);
    }
}
File diag_ctxt.h:

#pragma once

#include <vector>
#include <memory>

#include "emitter.h"

class DiagCtxt {
public:
    DiagCtxt(std::shared_ptr<Emitter> emitter);

    void addDiagnostic(const Diagnostic &diag);
    bool hasErrors() const;
    void emitDiagnostics();

private:
    std::vector<Diagnostic> diagnostics;
    std::shared_ptr<Emitter> emitter;
};
File emitter.cpp:

#include "emitter.h"
#include "log.h"

#include <fmt/core.h>
#include <fmt/color.h>
#include <fmt/ostream.h>

// #include <spdlog/fmt/bundled/core.h>
// #include <spdlog/fmt/bundled/color.h>
// #include <spdlog/fmt/bundled/ostream.h>

#include <utf8proc.h>

Emitter::Emitter(std::shared_ptr<SourceMap> sourceMap, std::ostream &outStream, bool useColor)
    : sourceMap(std::move(sourceMap)), out(outStream), useColor(useColor)
{
}

void Emitter::emit(const Diagnostic &diag)
{
    printHeader(diag);
    printLabels(diag);
}

void Emitter::printHeader(const Diagnostic &diag)
{
    auto levelStr = formatLevel(diag.getLevel());
    auto message = diag.getMessage();

    fmt::memory_buffer buffer;
    fmt::format_to(std::back_inserter(buffer), "{}: {}\n", levelStr, message);
    out.write(buffer.data(), buffer.size());
}

void Emitter::printLabels(const Diagnostic &diag)
{
    for (const auto &[span, labelMsg] : diag.getLabels()) {
        std::filesystem::path filePath;
        std::size_t lineNumberZeroBased, columnNumberZeroBased;
        sourceMap->spanToLocation(span, filePath, lineNumberZeroBased, columnNumberZeroBased);

        auto sourceFile = sourceMap->lookupSourceFile(span.lo);
        if (sourceFile) {
            std::string lineContent = sourceFile->getLine(lineNumberZeroBased);
            std::size_t lineStartByte = sourceFile->getLineStart(lineNumberZeroBased);
            std::size_t byteOffsetInLine = span.lo - lineStartByte;
            std::size_t byteLength = span.hi - span.lo;

            fmt::memory_buffer buffer;
            if (useColor) {
                fmt::format_to(std::back_inserter(buffer), "{} {}:{}:{}\n", fmt::format(fg(fmt::color::cyan), "  -->"),
                               filePath.string(), lineNumberZeroBased + 1, columnNumberZeroBased + 1);
            } else {
                fmt::format_to(std::back_inserter(buffer), "  --> {}:{}:{}\n", filePath.string(),
                               lineNumberZeroBased + 1, columnNumberZeroBased + 1);
            }

            if (useColor) {
                fmt::format_to(std::back_inserter(buffer), "   {} {} {}\n",
                               fmt::format(fg(fmt::color::cyan), "{}", lineNumberZeroBased + 1),
                               fmt::format(fg(fmt::color::cyan), "|"), lineContent);

            } else {
                fmt::format_to(std::back_inserter(buffer), "   {} | {}\n", lineNumberZeroBased + 1, lineContent);
            }

            // Print underline
            std::string underline = createUnderline(lineContent, byteOffsetInLine, byteLength);
            if (useColor) {
                fmt::format_to(std::back_inserter(buffer), "     {} {}\n", fmt::format(fg(fmt::color::cyan), "|"),
                               underline);
            } else {
                fmt::format_to(std::back_inserter(buffer), "     | {}\n", underline);
            }

            // Print label message
            if (!labelMsg.empty()) {
                fmt::format_to(std::back_inserter(buffer), "     = {}\n", labelMsg);
            }

            out.write(buffer.data(), buffer.size());
        }
    }
}

std::string Emitter::formatLevel(Diagnostic::Level level)
{
    if (useColor) {
        switch (level) {
        case Diagnostic::Level::Error:
            return fmt::format(fmt::emphasis::bold | fg(fmt::color::red), "error");
        case Diagnostic::Level::Warning:
            return fmt::format(fmt::emphasis::bold | fg(fmt::color::yellow), "warning");
        case Diagnostic::Level::Note:
            return fmt::format(fmt::emphasis::bold | fg(fmt::color::cyan), "note");
        }
    } else {
        switch (level) {
        case Diagnostic::Level::Error:
            return "error";
        case Diagnostic::Level::Warning:
            return "warning";
        case Diagnostic::Level::Note:
            return "note";
        }
    }
    return "unknown";
}

int Emitter::calculateDisplayWidth(const std::string &text)
{
    int width = 0;
    const char *str = text.c_str();
    utf8proc_ssize_t len = text.size();
    utf8proc_ssize_t idx = 0;
    utf8proc_int32_t codepoint;
    while (idx < len) {
        utf8proc_ssize_t charLen = utf8proc_iterate((const utf8proc_uint8_t *)(str + idx), len - idx, &codepoint);
        if (charLen <= 0) {
            LOG_DETAILED_ERROR("Invalid utf-8 formatting in calculateDisplayWidth");
            break;
        }

        width += utf8proc_charwidth(codepoint);
        idx += charLen;
    }
    return width;
}

std::string Emitter::createUnderline(const std::string &lineContent, std::size_t byteOffsetInLine,
                                     std::size_t byteLength)
{
    // Extract substrings
    std::string beforeUnderline = lineContent.substr(0, byteOffsetInLine);
    std::string underlineText = lineContent.substr(byteOffsetInLine, byteLength);

    int offsetWidth = calculateDisplayWidth(beforeUnderline);
    int underlineWidth = calculateDisplayWidth(underlineText);

    // Create the underline string
    std::string underline(offsetWidth, ' ');
    if (underlineWidth == 0) {
        LOG_DETAILED_ERROR("underlineWidth is 0");
    }
    std::string carets(underlineWidth > 0 ? underlineWidth : 1, '^');

    if (useColor) {
        underline += fmt::format(fmt::emphasis::bold | fg(fmt::color::red), "{}", carets);
    } else {
        underline += carets;
    }
    return underline;
}
File emitter.h:

#pragma once

#include "source_map.h"
#include "diagnostic.h"

#include <memory>
#include <ostream>
#include <iostream>

class Emitter {
public:
    Emitter(std::shared_ptr<SourceMap> sourceMap, std::ostream &outStream = std::cout, bool useColor = true);

    void emit(const Diagnostic &diag);

private:
    std::shared_ptr<SourceMap> sourceMap;
    std::ostream &out;
    bool useColor;

    void printHeader(const Diagnostic &diag);
    void printLabels(const Diagnostic &diag);

    std::string formatLevel(Diagnostic::Level level);
    std::string formatMessage(const std::string &message);
    std::string formatLocation(const std::filesystem::path &path, std::size_t line, std::size_t column);
    std::string createUnderline(const std::string &lineContent, std::size_t byteOffsetInLine, std::size_t byteLength);
    int calculateDisplayWidth(const std::string &text);
};

File log.cpp:

File log.h:

#pragma once
#define LOG_DETAILED_ERROR(...)
File main.cpp:

#include "log.h"
#include "preprocessor.h"
#include "symbol_table.h"
#include "parser.h"
#include "session.h"

#include <iostream>
#include <memory>
#include <fmt/core.h>
#include <filesystem>

#ifdef _WIN32
#    include <windows.h>
#endif

void setupConsoleForUtf8()
{
#ifdef _WIN32
    // Set console output code page to UTF-8 on Windows
    SetConsoleOutputCP(CP_UTF8);
#endif
}

int main(/* int argc, char *argv[]*/)
{
    setupConsoleForUtf8();
    // Log::init();

    std::filesystem::path filename = "examples/test.asm";

    auto parseSess = std::make_shared<ParseSession>();
    auto sourceFile = parseSess->sourceMap->loadFile(filename);

    if (sourceFile) {
        auto tokenizer = Tokenizer(parseSess, sourceFile->getSource(), 0);
        auto preprocessor = Preprocessor(parseSess);

        std::vector<Token> tokens = tokenizer.tokenize();
        tokens = preprocessor.preprocess(tokens);
        Parser parser(parseSess, tokens);
        parser.parse();
    } else {
        Diagnostic diag(Diagnostic::Level::Error, "failed to open file");
        parseSess->dcx->addDiagnostic(diag);
    }

    // TESTING
    std::string errMsg = "hey";

    Diagnostic diag(Diagnostic::Level::Error, errMsg);
    std::string test_string = sourceFile->getSource();
    int idx = 0;
    while (idx < test_string.size()) {
        if (test_string[idx] == 'o') {
            break;
        }
        idx++;
    }
    diag.addLabel(Span(idx, idx + 1, nullptr), "Unexpected token here");
    // diag.addLabel(Span(idx+1, idx + 2, nullptr), "Unexpected token here");

    parseSess->dcx->addDiagnostic(diag);

    if (parseSess->dcx->hasErrors()) {
        parseSess->dcx->emitDiagnostics();
    } else {
        fmt::print("Parsing completed successfully with no errors.\n");
    }
    return 0;
}

File parser.cpp:

#include "parser.h"
#include "symbol_table.h"
#include "diag_ctxt.h"

// #include <fmt/core.h>

Parser::Parser(std::shared_ptr<ParseSession> parseSession, const std::vector<Token> &tokens)
    : parseSess(parseSession), tokens(tokens)
{
}

void Parser::parse()
{
    currentIndex = 0;
    while (currentIndex < tokens.size()) {
        advance();
        if (currentToken.type == TokenType::EndOfFile) {
            return; // End parsing when EOF is reached
        }
        parseLine();
    }
}

void Parser::advance()
{
    if (currentIndex < tokens.size()) {
        currentToken = tokens[currentIndex++];
    } else {
        currentToken = {TokenType::EndOfFile, "", Span(1, 2, nullptr)};
    }
}

void Parser::parseLine()
{
    if (currentToken.type == TokenType::Identifier) {
        // Possible label or instruction
        if (currentIndex < tokens.size() && tokens[currentIndex].lexeme == ":") {
            // It's a label
            parseSess->symbolTable->addSymbol({currentToken.lexeme, Symbol::Type::Label});
            advance();
            advance();
            // parseLine();
        } else {
            // Treat as instruction or directive
            // parseInstruction();
        }
    } else if (currentToken.type == TokenType::Directive) {
        // parseDirective();
    } else if (currentToken.type == TokenType::Instruction) {
        // parseInstruction();
    } else if (currentToken.type == TokenType::Comment) {
        // Comment line
    } else {
        // Syntax error
    }
}

File parser.h:

#pragma once

#include "tokenize.h"
#include "symbol_table.h"
#include "diag_ctxt.h"
#include "preprocessor.h"
#include "session.h"

class Parser {
public:
    Parser(std::shared_ptr<ParseSession> parseSession, const std::vector<Token> &tokens);
    void parse();

private:
    std::shared_ptr<ParseSession> parseSess;

    Token currentToken;
    const std::vector<Token> &tokens;
    int currentIndex;

    void advance();
    void parseLine();
};
File preprocessor.cpp:

#include "preprocessor.h"
#include "tokenize.h"
#include <sstream>
#include <algorithm>
#include <stdexcept>

std::vector<Token> Preprocessor::preprocess(const std::vector<Token> &tokens)
{
    // TODO
    return tokens;
}

File preprocessor.h:

#pragma once

#include "diag_ctxt.h"
#include "tokenize.h"
#include "session.h"
#include <string>
#include <vector>
#include <stack>
#include <unordered_map>
#include <memory>

class Preprocessor {
public:
    Preprocessor(std::shared_ptr<ParseSession> parseSess) : parseSess(parseSess) {}
    std::vector<Token> preprocess(const std::vector<Token> &tokens);

private:
    std::shared_ptr<ParseSession> parseSess;
};

File session.cpp:

#include "session.h"

#include <iostream>

ParseSession::ParseSession()
{
    sourceMap = std::make_shared<SourceMap>();
    // bool useColor = !isOutputRedirected(std::cout);
    bool useColor = true;
    auto emitter = std::make_shared<Emitter>(sourceMap, std::cout, useColor);
    dcx = std::make_shared<DiagCtxt>(emitter);
    symbolTable = std::make_shared<SymbolTable>();
}

File session.h:

#pragma once

#include <memory>
#include <string>
#include <filesystem>

#include "symbol_table.h"
#include "source_map.h"
#include "diag_ctxt.h"

class ParseSession {
public:
    ParseSession();

public:
    std::shared_ptr<DiagCtxt> dcx;
    std::shared_ptr<SourceMap> sourceMap;
    std::shared_ptr<SymbolTable> symbolTable;
};
File source_map.cpp:

#include "source_map.h"
#include "log.h"
#include "span.h"

#include <fstream>
#include <filesystem>

SourceFile::SourceFile(const std::filesystem::path &path, const std::string &src, std::size_t startPos)
    : path(path), src(src), startPos(startPos), endPos(startPos + src.size())
{
    // Initialize lineStarts
    lineStarts.push_back(0);
    for (std::size_t i = 0; i < src.size(); ++i) {
        if (src[i] == '\n') {
            lineStarts.push_back(i + 1);
        }
    }
}

const std::filesystem::path &SourceFile::getPath() const { return path; }

const std::string &SourceFile::getSource() const { return src; }

std::size_t SourceFile::getStartPos() const { return startPos; }

std::size_t SourceFile::getEndPos() const { return endPos; }

std::size_t SourceFile::getLineNumber(std::size_t pos) const
{
    if (pos < startPos || pos >= endPos) {
        LOG_DETAILED_ERROR("Position out of range in getLineNumber");
        return 0;
    }
    std::size_t localPos = pos - startPos;
    auto it = std::upper_bound(lineStarts.begin(), lineStarts.end(), localPos);
    return (it - lineStarts.begin()) - 1;
}

// lineNumber is zero based
std::string SourceFile::getLine(std::size_t lineNumber) const
{
    if (lineNumber >= lineStarts.size()) {
        LOG_DETAILED_ERROR("Line number out of range in getLine");
        return "";
    }
    std::size_t start = lineStarts[lineNumber];
    std::size_t end;
    if (lineNumber + 1 < lineStarts.size()) {
        end = lineStarts[lineNumber + 1];
    } else {
        end = src.size();
    }

    // Exclude the newline character at the end if present
    if (end > start && src[end - 1] == '\n') {
        end--;
    }
    return src.substr(start, end - start);
}

// lineNumber is zero based
std::size_t SourceFile::getLineStart(std::size_t lineNumber) const
{
    if (lineNumber >= lineStarts.size()) {
        LOG_DETAILED_ERROR("Line number out of range in getLineStart");
        return 0;
    }
    return lineStarts[lineNumber];
}

std::size_t SourceFile::countCodePoints(const std::string &str, std::size_t startByte, std::size_t endByte)
{
    std::size_t codePointCount = 0;
    std::size_t i = startByte;
    while (i < endByte) {
        unsigned char c = static_cast<unsigned char>(str[i]);
        std::size_t charSize = 1;
        if ((c & 0x80) == 0x00) {
            charSize = 1; // ASCII character
        } else if ((c & 0xE0) == 0xC0) {
            charSize = 2; // 2-byte sequence
        } else if ((c & 0xF0) == 0xE0) {
            charSize = 3; // 3-byte sequence
        } else if ((c & 0xF8) == 0xF0) {
            charSize = 4; // 4-byte sequence
        } else {
            // Invalid UTF-8 start byte
            LOG_DETAILED_ERROR("Invalid UTF-8 encoding in countCodePoints");
            charSize = 1;
        }

        // Move to the next character
        i += charSize;
        codePointCount++;
    }
    return codePointCount;
}

std::size_t SourceFile::getColumnNumber(std::size_t pos) const
{
    std::size_t lineNumber = getLineNumber(pos);
    std::size_t lineStartPos = lineStarts[lineNumber];
    std::size_t localPos = pos - startPos;

    // Count code points between lineStartPos and localPos
    return countCodePoints(src, lineStartPos, localPos);
}

std::shared_ptr<SourceFile> SourceMap::newSourceFile(const std::filesystem::path &path, const std::string &src)
{
    std::size_t startPos = 0;
    if (!files.empty()) {
        startPos = files.back()->getEndPos();
    }
    auto file = std::make_shared<SourceFile>(path, src, startPos);
    files.push_back(file);
    return file;
}

std::shared_ptr<SourceFile> SourceMap::loadFile(const std::filesystem::path &path)
{
    auto existingFile = getSourceFile(path);
    if (existingFile) {
        return existingFile;
    }

    std::ifstream file(path);
    if (!file.is_open()) {
        return nullptr;
    }

    std::stringstream buffer;
    buffer << file.rdbuf();
    std::string content = buffer.str();

    return newSourceFile(path, content);
}

std::shared_ptr<SourceFile> SourceMap::lookupSourceFile(std::size_t pos) const
{
    for (const auto &file : files) {
        if (file->getStartPos() <= pos && pos < file->getEndPos()) {
            return file;
        }
    }
    return nullptr;
}

std::shared_ptr<SourceFile> SourceMap::getSourceFile(const std::filesystem::path &path) const
{
    for (const auto &file : files) {
        if (file->getPath() == path) {
            return file;
        }
    }
    return nullptr;
}

std::pair<std::size_t, std::size_t> SourceMap::lookupLineColumn(std::size_t pos) const
{
    auto file = lookupSourceFile(pos);
    if (file) {
        std::size_t lineNumber = file->getLineNumber(pos);
        std::size_t columnNumber = file->getColumnNumber(pos);
        return {lineNumber + 1, columnNumber + 1}; // Lines and columns are 1-based
    } else {
        return {0, 0};
    }
}

void SourceMap::spanToLocation(const Span &span, std::filesystem::path &outPath, std::size_t &outLine,
                               std::size_t &outColumn) const
{
    auto file = lookupSourceFile(span.lo);
    if (file) {
        outPath = file->getPath();
        outLine = file->getLineNumber(span.lo);     // Zero-based
        outColumn = file->getColumnNumber(span.lo); // Zero-based
    } else {
        outPath.clear();
        outLine = 0;
        outColumn = 0;
    }
}

std::string SourceMap::spanToSnippet(const Span &span) const
{
    auto sourceFile = lookupSourceFile(span.lo);
    if (!sourceFile) {
        LOG_DETAILED_ERROR("Span does not belong to any source file");
        return "";
    }

    std::size_t start_pos = span.lo - sourceFile->getStartPos();
    std::size_t end_pos = span.hi - sourceFile->getStartPos();

    if (end_pos > sourceFile->getSource().size()) {
        LOG_DETAILED_ERROR("Span end position out of range");
        return "";
    }

    return sourceFile->getSource().substr(start_pos, end_pos - start_pos);
}
File source_map.h:

#pragma once

#include <unordered_map>
#include <filesystem>
#include "span.h"

class SourceFile {
public:
    SourceFile(const std::filesystem::path &path, const std::string &src, std::size_t startPos);

    const std::filesystem::path &getPath() const;
    const std::string &getSource() const;

    std::size_t getStartPos() const;
    std::size_t getEndPos() const;

    // Maps a byte position to a line number (zer based)
    std::size_t getLineNumber(std::size_t pos) const;

    std::string getLine(std::size_t lineNumber) const;

    // Maps a byte position to a column number within its line (zero based)
    std::size_t getColumnNumber(std::size_t pos) const;

    std::size_t getLineStart(std::size_t lineNumber) const;

    static std::size_t countCodePoints(const std::string &str, std::size_t startByte, std::size_t endByte);

private:
    std::filesystem::path path;          
    std::string src;                     // Source code content
    std::size_t startPos;                // Starting position in the global source map (including startPos)
    std::size_t endPos;                  // Ending position in the global source map (excluding endPos)
    std::vector<std::size_t> lineStarts; // Byte positions where each line starts
};

class SourceMap {
public:
    SourceMap() {};

    std::shared_ptr<SourceFile> newSourceFile(const std::filesystem::path &path, const std::string &src);

    std::shared_ptr<SourceFile> loadFile(const std::filesystem::path &path);

    std::shared_ptr<SourceFile> lookupSourceFile(std::size_t pos) const;

    std::shared_ptr<SourceFile> getSourceFile(const std::filesystem::path &path) const;

    // Maps a global byte position to line and column (zero based)
    std::pair<std::size_t, std::size_t> lookupLineColumn(std::size_t pos) const;

    // Maps a span to file path, line, and column (zero based)
    void spanToLocation(const Span &span, std::filesystem::path &outPath, std::size_t &outLine,
                        std::size_t &outColumn) const;

    // Retrieves the source code snippet corresponding to a span
    std::string spanToSnippet(const Span &span) const;

private:
    std::vector<std::shared_ptr<SourceFile>> files;
};
File span.cpp:

#include "span.h"
#include "log.h"

void SyntaxContextData::pushMacro(const std::string &macroName) { macroStack.push_back(macroName); }

void SyntaxContextData::popMacro()
{
    if (!macroStack.empty()) {
        macroStack.pop_back();
    }
}

const std::string &SyntaxContextData::currentMacro() const { return macroStack.empty() ? "" : macroStack.back(); }

bool Span::contains(std::size_t pos) const { return lo <= pos && pos < hi; }

bool Span::overlaps(const Span &other) const { return lo < other.hi && other.lo < hi; }

Span Span::merge(const Span &first, const Span &second)
{
    std::size_t new_lo = std::min(first.lo, second.lo);
    std::size_t new_hi = std::max(first.hi, second.hi);

    std::shared_ptr<SyntaxContextData> new_context = first.context;

    if (first.context != second.context) {
        LOG_DETAILED_ERROR("Can't merge spans with different contexts!");
        return Span(0, 0, nullptr);
    }

    return Span(new_lo, new_hi, new_context);
}
File span.h:

#pragma once

#include <cstddef>
#include <string>
#include <vector>
#include <memory>

struct SyntaxContextData {
    std::vector<std::string> macroStack;

    void pushMacro(const std::string &macroName);

    void popMacro();

    const std::string &currentMacro() const;
};

struct Span {
    Span() : lo(0), hi(0), context(nullptr) {};
    Span(std::size_t start, std::size_t end, std::shared_ptr<SyntaxContextData> ctxt)
        : lo(start), hi(end), context(ctxt) {};

    bool contains(std::size_t pos) const;
    bool overlaps(const Span &other) const;

    static Span merge(const Span &first, const Span &second);

    // absolute offsets in bytes from SourceMap
    // the range is [lo, hi) bytes
    std::size_t lo;
    std::size_t hi;

    std::shared_ptr<SyntaxContextData> context;
};
File symbol_table.cpp:

#include "symbol_table.h"

void SymbolTable::addSymbol(const Symbol &symbol) { symbols[symbol.name] = symbol; }

Symbol *SymbolTable::findSymbol(const std::string &name)
{
    auto it = symbols.find(name);
    if (it != symbols.end()) {
        return &(it->second);
    }
    return nullptr;
}

File symbol_table.h:

#pragma once

#include <string>
#include <unordered_map>

struct Symbol {
    std::string name;
    enum class Type { Label, Variable, Macro, Segment };
    Type type;
    int lineNumber;
    std::string fileName;
};

class SymbolTable {
public:
    void addSymbol(const Symbol &symbol);
    Symbol *findSymbol(const std::string &name);

private:
    std::unordered_map<std::string, Symbol> symbols;
};

File timer.h:

#pragma once

#include <chrono>
#include <iostream>
#include <string>

class Timer {
public:
    Timer() { reset(); }

    void reset() { m_start = std::chrono::high_resolution_clock::now(); }

    float elapsed()
    {
        return static_cast<float>(std::chrono::duration_cast<std::chrono::nanoseconds>(
                                      std::chrono::high_resolution_clock::now() - m_start)
                                      .count()) *
               0.001f * 0.001f * 0.001f;
    }

    float elapsed_millis() { return elapsed() * 1000.0f; }

private:
    std::chrono::time_point<std::chrono::high_resolution_clock> m_start;
};

// class ScopedTimer
// {
// public:
//     explicit ScopedTimer(const std::string &name) : m_name(name) {}
//     ~ScopedTimer() // NOLINT(cppcoreguidelines-special-member-functions): not using heap allocated memory here
//     {
//         const float time = m_timer.elapsed_millis();
//          LOG
//     }

// private:
//     std::string m_name;
//     Timer m_timer;
// };
File tokenize.cpp:

#include "tokenize.h"
#include <algorithm>
#include <cctype>

std::vector<Token> Tokenizer::tokenize()
{
    std::vector<Token> tokens;

    while (pos < src.size()) {

        pos++;
    }

    return tokens;
}

File tokenize.h:

#pragma once

#include "span.h"
#include "session.h"
#include <string>
#include <deque>
#include <unordered_set>

enum class TokenType {
    Identifier,
    Directive,
    Instruction,
    Register,
    Number,
    StringLiteral,
    Operator,
    Separator,
    EndOfFile,
    EndOfLine,
    Comment,
};

struct Token {
    enum TokenType type;
    std::string lexeme;
    Span span;

    // data about macro expansion
};

class Tokenizer {
public:
    Tokenizer(std::shared_ptr<ParseSession> psess, const std::string &src, std::size_t startPos)
        : psess(psess), startPos(startPos), src(src), pos(startPos)
    {
    }
    std::vector<Token> tokenize();

private:
    std::size_t startPos;
    std::size_t pos;
    const std::string &src;
    std::shared_ptr<ParseSession> psess;
};
File test_add.cpp:

#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
#include <doctest/doctest.h>
#include "add.h"

// int add(int a, int b) { return a + b; }

TEST_CASE("testing the add function") {
    CHECK(add(1, 2) == 3);
    CHECK(add(2, 5) == 7);
}
