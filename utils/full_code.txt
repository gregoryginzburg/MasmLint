File add.cpp:

int add(int aaa, int bbb) { return aaa + bbb; }

int mul(int aaa, int bbb) { return aaa * bbb; }

File add.h:

#pragma once

int add(int a, int b);
int mul(int a, int b);
File ast.h:

#pragma once

#include "token.h"
#include "log.h"
#include "diagnostic.h"
#include <memory>
#include <optional>
#include <map>
#include <iostream>

class AST;
class Expression;
class Statement;
class EndDir;
class Instruction;
class Directive;
class InitializerList;
class RecordField;
using ASTPtr = std::shared_ptr<AST>;
using ExpressionPtr = std::shared_ptr<Expression>;

#define INVALID(node) (node->diagnostic)
#define INVALID_EXPRESSION(diag) (std::make_shared<Expression>(diag))

#define INVALID_STATEMENT(diag) (std::make_shared<Statement>(diag))

#define INVALID_SEG_DIR(diag) (std::make_shared<SegDir>(diag))
#define INVALID_DATA_DIR(diag) (std::make_shared<DataDir>(diag))
#define INVALID_STRUCT_DIR(diag) (std::make_shared<StructDir>(diag))
#define INVALID_PROC_DIR(diag) (std::make_shared<ProcDir>(diag))
#define INVALID_RECORD_DIR(diag) (std::make_shared<RecordDir>(diag))
#define INVALID_RECORD_FIELD(diag) (std::make_shared<RecordField>(diag))
#define INVALID_EQU_DIR(diag) (std::make_shared<EquDir>(diag))
#define INVALID_EQUAL_DIR(diag) (std::make_shared<EqualDir>(diag))
#define INVALID_END_DIR(diag) (std::make_shared<EndDir>(diag))

#define INVALID_INSTRUCTION(diag) (std::make_shared<Instruction>(diag))
#define INVALID_LABEL_DEF(diag) (std::make_shared<LabelDef>(diag))

#define INVALID_DATA_ITEM(diag) (std::make_shared<DataItem>(diag))
#define INVALID_INIT_VALUE(diag) (std::make_shared<InitValue>(diag))
#define INVALID_INITIALIZER_LIST(diag) (std::make_shared<InitializerList>(diag))

class AST {
public:
    AST() = default;

    virtual ~AST() = default;

    AST(const AST &) = default;
    AST &operator=(const AST &) = default;

    AST(AST &&) = default;
    AST &operator=(AST &&) = default;

    mutable std::optional<std::shared_ptr<Diagnostic>> diagnostic;
};

class Program : public AST {
public:
    Program(const std::vector<std::shared_ptr<Statement>> &sentences, std::shared_ptr<Directive> endDir) : statements(sentences), endDir(endDir) {}
    std::vector<std::shared_ptr<Statement>> statements;
    std::shared_ptr<Directive> endDir;
};

class Statement : public AST {
public:
    Statement() = default;
    Statement(std::optional<std::shared_ptr<Diagnostic>> diag) { diagnostic = diag; }
    Statement(std::shared_ptr<Diagnostic> diag) { diagnostic = diag; }
};

// Init values
class InitValue : public AST {
public:
    InitValue() = default;
    InitValue(std::optional<std::shared_ptr<Diagnostic>> diag) { diagnostic = diag; }
};

class DupOperator : public InitValue {
public:
    DupOperator(ExpressionPtr repeatCount, Token op, Token leftBracket, std::shared_ptr<InitializerList> operands, Token rightBracket)
        : repeatCount(std::move(repeatCount)), op(std::move(op)), leftBracket(std::move(leftBracket)), operands(std::move(operands)),
          rightBracket(std::move(rightBracket))
    {
    }
    ExpressionPtr repeatCount;
    Token op;
    Token leftBracket;
    std::shared_ptr<InitializerList> operands;
    Token rightBracket;
};

class QuestionMarkInitValue : public InitValue {
public:
    QuestionMarkInitValue(Token token) : token(std::move(token)) {}
    Token token;
};

class ExpressionInitValue : public InitValue {
public:
    ExpressionInitValue(ExpressionPtr expr) : expr(std::move(expr)) {}
    ExpressionPtr expr;
};

class StructOrRecordInitValue : public InitValue {
public:
    StructOrRecordInitValue(Token leftBracket, Token rightBracket, std::shared_ptr<InitializerList> fields)
        : initList(std::move(fields)), leftBracket(std::move(leftBracket)), rightBracket(std::move(rightBracket))
    {
    }
    Token leftBracket;
    Token rightBracket;
    std::shared_ptr<InitializerList> initList;
};

class InitializerList : public InitValue {
public:
    InitializerList(std::optional<std::shared_ptr<Diagnostic>> diag) { diagnostic = diag; }
    InitializerList(std::shared_ptr<Diagnostic> diag) { diagnostic = diag; }
    InitializerList(std::vector<std::shared_ptr<InitValue>> fields) : fields(std::move(fields)) {}
    std::vector<std::shared_ptr<InitValue>> fields;
};

// Define data (data items)
class DataItem : public AST {
public:
    Token dataTypeToken;
    std::shared_ptr<InitializerList> initValues;

    DataItem() = default;
    DataItem(std::optional<std::shared_ptr<Diagnostic>> diag) { diagnostic = diag; }
    DataItem(Token dataTypeToken, std::shared_ptr<InitializerList> initValues)
        : dataTypeToken(std::move(dataTypeToken)), initValues(std::move(initValues))
    {
    }
};

// Directives
class Directive : public Statement {};

class SegDir : public Directive {
public:
    Token directiveToken;
    std::optional<ExpressionPtr> constExpr;

    SegDir(std::optional<std::shared_ptr<Diagnostic>> diag) { diagnostic = diag; }
    SegDir(std::shared_ptr<Diagnostic> diag) { diagnostic = diag; }
    SegDir(Token directiveToken, std::optional<ExpressionPtr> constExpr = std::nullopt)
        : directiveToken(std::move(directiveToken)), constExpr(std::move(constExpr))
    {
    }
};

class DataDir : public Directive {
public:
    std::optional<Token> idToken;
    std::shared_ptr<DataItem> dataItem;

    DataDir(std::optional<std::shared_ptr<Diagnostic>> diag) { diagnostic = diag; }
    DataDir(std::shared_ptr<Diagnostic> diag) { diagnostic = diag; }
    DataDir(std::optional<Token> idToken, std::shared_ptr<DataItem> dataItem) : idToken(std::move(idToken)), dataItem(std::move(dataItem)) {}
};

class StructDir : public Directive {
public:
    Token firstIdToken;
    Token directiveToken;
    std::vector<std::shared_ptr<DataDir>> fields;
    Token secondIdToken;
    Token endsDirToken;

    StructDir(std::optional<std::shared_ptr<Diagnostic>> diag) { diagnostic = diag; }
    StructDir(std::shared_ptr<Diagnostic> diag) { diagnostic = diag; }
    StructDir(Token firstIdToken, Token directiveToken, const std::vector<std::shared_ptr<DataDir>> &fields, Token secondIdToken, Token endsDirToken)
        : firstIdToken(std::move(firstIdToken)), directiveToken(std::move(directiveToken)), fields(fields), secondIdToken(std::move(secondIdToken)),
          endsDirToken(std::move(endsDirToken))
    {
    }
};

class RecordDir : public Directive {
public:
    Token idToken;
    Token directiveToken;
    std::vector<std::shared_ptr<RecordField>> fields;

    RecordDir() = default;
    RecordDir(std::optional<std::shared_ptr<Diagnostic>> diag) { diagnostic = diag; }
    RecordDir(std::shared_ptr<Diagnostic> diag) { diagnostic = diag; }
    RecordDir(Token idToken, Token directiveToken, std::vector<std::shared_ptr<RecordField>> fields)
        : idToken(std::move(idToken)), directiveToken(std::move(directiveToken)), fields(std::move(fields))
    {
    }
};

class RecordField : public AST {
public:
    Token fieldToken;
    ExpressionPtr width;
    std::optional<ExpressionPtr> initialValue;

    RecordField(std::optional<std::shared_ptr<Diagnostic>> diag) { diagnostic = diag; }
    RecordField(std::shared_ptr<Diagnostic> diag) { diagnostic = diag; }
    RecordField(Token fieldToken, ExpressionPtr width, std::optional<ExpressionPtr> initialValue)
        : fieldToken(std::move(fieldToken)), width(std::move(width)), initialValue(std::move(initialValue))
    {
    }
};

class EquDir : public Directive {
public:
    Token idToken;
    Token directiveToken;
    ExpressionPtr value; // TODO: can also be a string

    EquDir(std::optional<std::shared_ptr<Diagnostic>> diag) { diagnostic = diag; }
    EquDir(std::shared_ptr<Diagnostic> diag) { diagnostic = diag; }
    EquDir(Token idToken, Token directiveToken, ExpressionPtr value)
        : idToken(std::move(idToken)), directiveToken(std::move(directiveToken)), value(std::move(value))
    {
    }
};

class EqualDir : public Directive {
public:
    Token idToken;
    Token directiveToken;
    ExpressionPtr value;

    EqualDir(std::optional<std::shared_ptr<Diagnostic>> diag) { diagnostic = diag; }
    EqualDir(std::shared_ptr<Diagnostic> diag) { diagnostic = diag; }
    EqualDir(Token idToken, Token directiveToken, ExpressionPtr value)
        : idToken(std::move(idToken)), directiveToken(std::move(directiveToken)), value(std::move(value))
    {
    }
};

class ProcDir : public Directive {
public:
    Token firstIdToken;
    Token directiveToken;
    std::vector<std::shared_ptr<Instruction>> instructions;
    Token secondIdToken;
    Token endpDirToken;

    ProcDir(std::optional<std::shared_ptr<Diagnostic>> diag) { diagnostic = diag; }
    ProcDir(std::shared_ptr<Diagnostic> diag) { diagnostic = diag; }
    ProcDir(Token firstIdToken, Token directiveToken, const std::vector<std::shared_ptr<Instruction>> &fields, Token secondIdToken,
            Token endsDirToken)
        : firstIdToken(std::move(firstIdToken)), directiveToken(std::move(directiveToken)), instructions(fields),
          secondIdToken(std::move(secondIdToken)), endpDirToken(std::move(endsDirToken))
    {
    }
};

class EndDir : public Directive {
public:
    Token endToken;
    std::optional<ExpressionPtr> addressExpr;

    EndDir(std::optional<std::shared_ptr<Diagnostic>> diag) { diagnostic = diag; }
    EndDir(std::shared_ptr<Diagnostic> diag) { diagnostic = diag; }
    EndDir(Token endToken, std::optional<ExpressionPtr> addressExpr) : endToken(std::move(endToken)), addressExpr(std::move(addressExpr)) {}
};

// Instructions
class Instruction : public Statement {
public:
    std::optional<Token> label;
    std::optional<Token> mnemonicToken;
    std::vector<ExpressionPtr> operands;

    Instruction(std::optional<std::shared_ptr<Diagnostic>> diag) { diagnostic = diag; }
    Instruction(std::shared_ptr<Diagnostic> diag) { diagnostic = diag; }
    Instruction(std::optional<Token> label, std::optional<Token> mnemonicToken, const std::vector<ExpressionPtr> &operands)
        : label(label), mnemonicToken(std::move(mnemonicToken)), operands(operands)
    {
    }
};

// Expressions
// UnfinishedMemoryOperand is when [] are forgotten
enum class OperandType : uint8_t { ImmediateOperand, RegisterOperand, MemoryOperand, UnfinishedMemoryOperand, Unspecified };

struct OperandSize {
    OperandSize(std::string symbol, int value) : symbol(std::move(symbol)), value(value) {}
    std::string symbol;
    int value;
};

class Expression : public AST {
public:
    Expression() = default;
    Expression(std::shared_ptr<Diagnostic> diag) { diagnostic = diag; }
    // expression attributes for semantic analysis
    std::optional<int64_t> constantValue;
    bool unresolvedSymbols = false;
    bool isRelocatable = false;
    std::map<Token, std::optional<int32_t>> registers;

    // attributes for later operands semantic analysis
    OperandType type = OperandType::Unspecified;
    std::optional<OperandSize> size = std::nullopt;
};

class BinaryOperator : public Expression {
public:
    BinaryOperator(Token op, ExpressionPtr left, ExpressionPtr right) : op(std::move(op)), left(std::move(left)), right(std::move(right)) {}

    Token op;
    ExpressionPtr left;
    ExpressionPtr right;
};

class Brackets : public Expression {
public:
    Brackets(Token leftBracket, Token rightBracket, ExpressionPtr operand)
        : leftBracket(std::move(leftBracket)), rightBracket(std::move(rightBracket)), operand(std::move(operand))
    {
    }
    Token leftBracket;
    Token rightBracket;
    ExpressionPtr operand;
};

class SquareBrackets : public Expression {
public:
    SquareBrackets(Token leftBracket, Token rightBracket, ExpressionPtr operand)
        : leftBracket(std::move(leftBracket)), rightBracket(std::move(rightBracket)), operand(std::move(operand))
    {
    }
    Token leftBracket;
    Token rightBracket;
    ExpressionPtr operand;
};

class ImplicitPlusOperator : public Expression {
public:
    ImplicitPlusOperator(ExpressionPtr left, ExpressionPtr right) : left(std::move(left)), right(std::move(right)) {}

    ExpressionPtr left;
    ExpressionPtr right;
};

class UnaryOperator : public Expression {
public:
    UnaryOperator(Token op, ExpressionPtr operand) : op(std::move(op)), operand(std::move(operand)) {}

    Token op;
    ExpressionPtr operand;
};

class Leaf : public Expression {
public:
    explicit Leaf(Token token) : token(std::move(token)) {}

    Token token;
};

inline void printAST(const ASTPtr &node, size_t indent)
{
    if (!node) {
        return;
    }

    // Create indentation string
    std::string indentation(indent, ' ');

    if (INVALID(node)) {
        std::cout << indentation << "Invalid Node: ";
        std::cout << node->diagnostic.value()->getMessage() << "\n";
        return;
    }

    if (auto program = std::dynamic_pointer_cast<Program>(node)) {
        std::cout << indentation << "Program\n";
        std::cout << indentation << "Statements:\n";
        for (const auto &stmt : program->statements) {
            printAST(stmt, indent + 2);
        }
        if (program->endDir) {
            std::cout << indentation << "End Directive:\n";
            printAST(program->endDir, indent + 2);
        }
    } else if (auto instruction = std::dynamic_pointer_cast<Instruction>(node)) {
        std::cout << indentation << "Instruction\n";
        if (instruction->label) {
            std::cout << indentation << "Label: " << instruction->label.value().lexeme << "\n";
        }
        if (!instruction->mnemonicToken) {
            return;
        }
        std::cout << indentation << "Mnemonic: " << instruction->mnemonicToken.value().lexeme << "\n";
        std::cout << indentation << "Operands:\n";
        for (const auto &operand : instruction->operands) {
            printAST(operand, indent + 2);
        }
    } else if (auto directive = std::dynamic_pointer_cast<Directive>(node)) {
        if (auto segDir = std::dynamic_pointer_cast<SegDir>(directive)) {
            std::cout << indentation << "Segment Directive\n";
            std::cout << indentation << "Directive Token: " << segDir->directiveToken.lexeme << "\n";
            if (segDir->constExpr) {
                std::cout << indentation << "Constant Expression:\n";
                printAST(*segDir->constExpr, indent + 2);
            }
        } else if (auto dataDir = std::dynamic_pointer_cast<DataDir>(directive)) {
            std::cout << indentation << "Data Directive\n";
            if (dataDir->idToken) {
                std::cout << indentation << "Identifier: " << dataDir->idToken->lexeme << "\n";
            }
            std::cout << indentation << "Data Item:\n";
            printAST(dataDir->dataItem, indent + 2);
        } else if (auto structDir = std::dynamic_pointer_cast<StructDir>(directive)) {
            std::cout << indentation << "Struct Directive\n";
            std::cout << indentation << "First Identifier: " << structDir->firstIdToken.lexeme << "\n";
            std::cout << indentation << "Directive Token: " << structDir->directiveToken.lexeme << "\n";
            std::cout << indentation << "Fields:\n";
            for (const auto &field : structDir->fields) {
                printAST(field, indent + 2);
            }
            std::cout << indentation << "Second Identifier: " << structDir->secondIdToken.lexeme << "\n";
            std::cout << indentation << "Ends Directive Token: " << structDir->endsDirToken.lexeme << "\n";
        } else if (auto recordDir = std::dynamic_pointer_cast<RecordDir>(directive)) {
            std::cout << indentation << "Record Directive\n";
            std::cout << indentation << "Identifier: " << recordDir->idToken.lexeme << "\n";
            std::cout << indentation << "Directive Token: " << recordDir->directiveToken.lexeme << "\n";
            std::cout << indentation << "Fields:\n";
            for (const auto &field : recordDir->fields) {
                printAST(field, indent + 2);
            }
        } else if (auto equDir = std::dynamic_pointer_cast<EquDir>(directive)) {
            std::cout << indentation << "Equ Directive\n";
            std::cout << indentation << "Identifier: " << equDir->idToken.lexeme << "\n";
            std::cout << indentation << "Directive Token: " << equDir->directiveToken.lexeme << "\n";
            std::cout << indentation << "Value:\n";
            printAST(equDir->value, indent + 2);
        } else if (auto equalDir = std::dynamic_pointer_cast<EqualDir>(directive)) {
            std::cout << indentation << "Equal Directive\n";
            std::cout << indentation << "Identifier: " << equalDir->idToken.lexeme << "\n";
            std::cout << indentation << "Directive Token: " << equalDir->directiveToken.lexeme << "\n";
            std::cout << indentation << "Value:\n";
            printAST(equalDir->value, indent + 2);
        } else if (auto procDir = std::dynamic_pointer_cast<ProcDir>(directive)) {
            std::cout << indentation << "Proc Directive\n";
            std::cout << indentation << "First Identifier: " << procDir->firstIdToken.lexeme << "\n";
            std::cout << indentation << "Directive Token: " << procDir->directiveToken.lexeme << "\n";
            std::cout << indentation << "Instructions:\n";
            for (const auto &instr : procDir->instructions) {
                printAST(instr, indent + 2);
            }
            std::cout << indentation << "Second Identifier: " << procDir->secondIdToken.lexeme << "\n";
            std::cout << indentation << "Endp Directive Token: " << procDir->endpDirToken.lexeme << "\n";
        } else if (auto endDir = std::dynamic_pointer_cast<EndDir>(directive)) {
            std::cout << indentation << "End Directive\n";
            std::cout << indentation << "End Token: " << endDir->endToken.lexeme << "\n";
            if (endDir->addressExpr) {
                std::cout << indentation << "Address Expression:\n";
                printAST(*endDir->addressExpr, indent + 2);
            }
        } else {
            std::cout << indentation << "Unhandled Directive Type\n";
        }
    } else if (auto dataItem = std::dynamic_pointer_cast<DataItem>(node)) {
        std::cout << indentation << "Builtin Instance\n";
        std::cout << indentation << "Data Type Token: " << dataItem->dataTypeToken.lexeme << "\n";
        std::cout << indentation << "Init Values:\n";
        printAST(dataItem->initValues, indent + 2);

    } else if (auto initValue = std::dynamic_pointer_cast<InitValue>(node)) {
        if (auto dupOperator = std::dynamic_pointer_cast<DupOperator>(initValue)) {
            std::cout << indentation << "Dup Operator\n";
            std::cout << indentation << "Repeat Count:\n";
            if (dupOperator->repeatCount) {
                printAST(dupOperator->repeatCount, indent + 2);
            }
            std::cout << indentation << "Operator: " << dupOperator->op.lexeme << "\n";
            std::cout << indentation << "Operands:\n";
            for (const auto &operand : dupOperator->operands->fields) {
                printAST(operand, indent + 2);
            }
        } else if (auto questionMarkInitValue = std::dynamic_pointer_cast<QuestionMarkInitValue>(initValue)) {
            std::cout << indentation << "Question Mark Init Value: " << questionMarkInitValue->token.lexeme << "\n";
        } else if (auto addressExprInitValue = std::dynamic_pointer_cast<ExpressionInitValue>(initValue)) {
            std::cout << indentation << "Expression Init Value:\n";
            printAST(addressExprInitValue->expr, indent + 2);
        } else if (auto structOrRecord = std::dynamic_pointer_cast<StructOrRecordInitValue>(initValue)) {
            std::cout << indentation << "Struct or Record Init Value\n";
            std::cout << indentation << "Left Bracket: " << structOrRecord->leftBracket.lexeme << "\n";
            std::cout << indentation << "Right Bracket: " << structOrRecord->rightBracket.lexeme << "\n";
            std::cout << indentation << "Fields:\n";
            printAST(structOrRecord->initList, indent + 2);
        } else if (auto initList = std::dynamic_pointer_cast<InitializerList>(initValue)) {
            std::cout << indentation << "Initializer List\n";
            for (const auto &operand : initList->fields) {
                printAST(operand, indent + 2);
            }
        } else {
            std::cout << indentation << "Unhandled InitValue Type\n";
        }
    } else if (auto expression = std::dynamic_pointer_cast<Expression>(node)) {
        if (auto binaryOp = std::dynamic_pointer_cast<BinaryOperator>(expression)) {
            std::cout << indentation << "Binary Operator (" << binaryOp->op.lexeme << ")\n";
            std::cout << indentation << "Left:\n";
            printAST(binaryOp->left, indent + 2);
            std::cout << indentation << "Right:\n";
            printAST(binaryOp->right, indent + 2);
        } else if (auto unaryOp = std::dynamic_pointer_cast<UnaryOperator>(expression)) {
            std::cout << indentation << "Unary Operator (" << unaryOp->op.lexeme << ")\n";
            std::cout << indentation << "Operand:\n";
            printAST(unaryOp->operand, indent + 2);
        } else if (auto brackets = std::dynamic_pointer_cast<Brackets>(expression)) {
            std::cout << indentation << "Brackets\n";
            std::cout << indentation << "Left Bracket: " << brackets->leftBracket.lexeme << "\n";
            std::cout << indentation << "Right Bracket: " << brackets->rightBracket.lexeme << "\n";
            std::cout << indentation << "Operand:\n";
            printAST(brackets->operand, indent + 2);
        } else if (auto squareBrackets = std::dynamic_pointer_cast<SquareBrackets>(expression)) {
            std::cout << indentation << "Square Brackets\n";
            std::cout << indentation << "Left Bracket: " << squareBrackets->leftBracket.lexeme << "\n";
            std::cout << indentation << "Right Bracket: " << squareBrackets->rightBracket.lexeme << "\n";
            std::cout << indentation << "Operand:\n";
            printAST(squareBrackets->operand, indent + 2);
        } else if (auto implicitPlus = std::dynamic_pointer_cast<ImplicitPlusOperator>(expression)) {
            std::cout << indentation << "Implicit Plus Operator\n";
            std::cout << indentation << "Left:\n";
            printAST(implicitPlus->left, indent + 2);
            std::cout << indentation << "Right:\n";
            printAST(implicitPlus->right, indent + 2);
        } else if (auto leaf = std::dynamic_pointer_cast<Leaf>(expression)) {
            std::cout << indentation << "Leaf (" << leaf->token.lexeme << ")\n";
        } else {
            std::cout << indentation << "Unhandled Expression Type\n";
        }
    } else if (auto recordField = std::dynamic_pointer_cast<RecordField>(node)) {
        std::cout << indentation << "Record Field\n";
        std::cout << indentation << "Field Token: " << recordField->fieldToken.lexeme << "\n";
        std::cout << indentation << "Width:\n";
        printAST(recordField->width, indent + 2);
        if (recordField->initialValue) {
            std::cout << indentation << "Initial Value:\n";
            printAST(*recordField->initialValue, indent + 2);
        }
    } else {
        std::cout << indentation << "Unhandled AST Node Type\n";
    }
}

inline Span getExpressionSpan(const ExpressionPtr &node)
{
    if (node->diagnostic) {
        return {0, 0, nullptr};
    }
    if (auto binaryOp = std::dynamic_pointer_cast<BinaryOperator>(node)) {
        return Span::merge(getExpressionSpan(binaryOp->left), getExpressionSpan(binaryOp->right));
    } else if (auto unaryOp = std::dynamic_pointer_cast<UnaryOperator>(node)) {
        return Span::merge(unaryOp->op.span, getExpressionSpan(unaryOp->operand));
    } else if (auto brackets = std::dynamic_pointer_cast<Brackets>(node)) {
        return Span::merge(brackets->leftBracket.span, brackets->rightBracket.span);
    } else if (auto squareBrackets = std::dynamic_pointer_cast<SquareBrackets>(node)) {
        return Span::merge(squareBrackets->leftBracket.span, squareBrackets->rightBracket.span);
    } else if (auto implicitPlus = std::dynamic_pointer_cast<ImplicitPlusOperator>(node)) {
        return Span::merge(getExpressionSpan(implicitPlus->left), getExpressionSpan(implicitPlus->right));
    } else if (auto leaf = std::dynamic_pointer_cast<Leaf>(node)) {
        return leaf->token.span;
    } else {
        LOG_DETAILED_ERROR("Unknown Expression Node!\n");
        return {0, 0, nullptr};
    }
}

inline Span getInitValueSpan(const std::shared_ptr<InitValue> &node)
{
    if (node->diagnostic) {
        return {0, 0, nullptr};
    }

    if (auto dupOperator = std::dynamic_pointer_cast<DupOperator>(node)) {
        Span span = getExpressionSpan(dupOperator->repeatCount);
        span = Span::merge(span, dupOperator->rightBracket.span);
        return span;
    }

    if (auto questionMarkInitValue = std::dynamic_pointer_cast<QuestionMarkInitValue>(node)) {
        return questionMarkInitValue->token.span;
    }

    if (auto expressionInitValue = std::dynamic_pointer_cast<ExpressionInitValue>(node)) {
        return getExpressionSpan(expressionInitValue->expr);
    }

    if (auto structOrRecord = std::dynamic_pointer_cast<StructOrRecordInitValue>(node)) {
        Span span = Span::merge(structOrRecord->leftBracket.span, structOrRecord->rightBracket.span);
        return span;
    }

    if (auto initList = std::dynamic_pointer_cast<InitializerList>(node)) {
        if (initList->fields.size() == 0) {
            LOG_DETAILED_ERROR("Initalizer list length can't be 0");
            return {0, 0, nullptr};
        }

        Span result = Span::merge(getInitValueSpan(initList->fields[0]), getInitValueSpan(initList->fields.back()));
        return result;
    }

    LOG_DETAILED_ERROR("Unknown InitValue node!\n");
    return {0, 0, nullptr};
}

File diagnostic.cpp:

#include "diagnostic.h"
#include "fmt/core.h"

// template <typename... Args>
// Diagnostic::Diagnostic(Level level, ErrorCode code, Args&&... args)
//     : level(level), code(code), message(fmt::format(getErrorMessage(code), std::forward<Args>(args)...)) {}

void Diagnostic::addPrimaryLabel(const Span &span, const std::string &labelMessage)
{
    primaryLabel = std::pair<Span, std::string>(span, labelMessage);
}

void Diagnostic::addSecondaryLabel(const Span &span, const std::string &labelMessage)
{
    secondaryLabels.emplace_back(span, labelMessage);
}

void Diagnostic::addNoteMessage(const std::string &msg) { noteMessage = msg; }

Diagnostic::Level Diagnostic::getLevel() const { return level; }

ErrorCode Diagnostic::getCode() const { return code; }

const std::string &Diagnostic::getMessage() const { return message; }

const std::pair<Span, std::string> &Diagnostic::getPrimaryLabel() const { return primaryLabel; }

const std::vector<std::pair<Span, std::string>> &Diagnostic::getSecondaryLabels() const { return secondaryLabels; }

const std::optional<std::string> &Diagnostic::getNoteMessage() const { return noteMessage; }

const std::optional<std::string> &Diagnostic::getHelpMessage() const { return helpMessage; }

void Diagnostic::cancel() { cancelled = true; }

bool Diagnostic::isCancelled() const { return cancelled; }

std::string getErrorMessage(ErrorCode code)
{
    switch (code) {
#define DEFINE_ERROR(code, message)                                                                                    \
    case ErrorCode::code:                                                                                              \
        return message;
#define DEFINE_WARNING(code, message)                                                                                  \
    case ErrorCode::code:                                                                                              \
        return message;
#include "diagnostic_messages.def"
#undef DEFINE_ERROR
#undef DEFINE_WARNING
    default:
        return "Unknown error.";
    }
}

File diagnostic.h:

#pragma once

#include <string>
#include <vector>
#include <optional>
#include <memory>
#include <fmt/core.h>

#include "span.h"
#include "error_codes.h"

std::string getErrorMessage(ErrorCode code);

class Diagnostic {
public:
    enum class Level : std::uint8_t { Error, Warning, Note };

    template <typename... Args>
    Diagnostic(Level level, ErrorCode code, Args &&...args)
        : level(level), code(code),
          message(fmt::format(fmt::runtime(getErrorMessage(code)), std::forward<Args>(args)...))
    {
    }

    void addPrimaryLabel(const Span &span, const std::string &labelMessage);
    void addSecondaryLabel(const Span &span, const std::string &labelMessage);

    void addNoteMessage(const std::string &msg);

    Level getLevel() const;
    ErrorCode getCode() const;
    const std::string &getMessage() const;
    const std::pair<Span, std::string> &getPrimaryLabel() const;
    const std::vector<std::pair<Span, std::string>> &getSecondaryLabels() const;
    const std::optional<std::string> &getNoteMessage() const;
    const std::optional<std::string> &getHelpMessage() const;

    void cancel();
    bool isCancelled() const;

private:
    Level level;
    ErrorCode code;
    std::string message;
    std::pair<Span, std::string> primaryLabel;
    std::vector<std::pair<Span, std::string>> secondaryLabels;

    std::optional<std::string> noteMessage;
    std::vector<std::pair<Span, std::string>> noteLabels;

    std::optional<std::string> helpMessage;
    // std::optional<std::string> stringToDelete;
    std::optional<std::string> stringToInsert;
    std::vector<Span> insertColor;
    std::vector<Span> deleteColor;

    bool cancelled = false;
};

File diag_ctxt.cpp:

#include "diag_ctxt.h"
#include "emitter.h"
#include "log.h"

DiagCtxt::DiagCtxt(std::shared_ptr<Emitter> emitter) : emitter(std::move(emitter)) {}

void DiagCtxt::addDiagnostic(const Diagnostic &diag) { diagnostics.push_back(std::make_shared<Diagnostic>(diag)); }

std::shared_ptr<Diagnostic> DiagCtxt::getLastDiagnostic()
{
    if (diagnostics.empty()) {
        LOG_DETAILED_ERROR("No last diagnostics exists!");
        return nullptr;
    }
    return diagnostics.back();
}

bool DiagCtxt::hasErrors() const { return !diagnostics.empty(); }

void DiagCtxt::emitDiagnostics()
{
    for (const auto &diag : diagnostics) {
        emitter->emit(diag);
    }
}

void DiagCtxt::emitJsonDiagnostics() { emitter->emitJSON(diagnostics); }
File diag_ctxt.h:

#pragma once

#include <vector>
#include <memory>

#include "emitter.h"

class DiagCtxt {
public:
    explicit DiagCtxt(std::shared_ptr<Emitter> emitter);

    void addDiagnostic(const Diagnostic &diag);
    std::shared_ptr<Diagnostic> getLastDiagnostic();
    bool hasErrors() const;
    void emitDiagnostics();
    void emitJsonDiagnostics();

private:
    std::vector<std::shared_ptr<Diagnostic>> diagnostics;
    std::shared_ptr<Emitter> emitter;
};
File emitter.cpp:

#include "emitter.h"
#include "log.h"

#include <fmt/core.h>
#include <fmt/color.h>
#include <fmt/ostream.h>
#include <map>
#include <algorithm>

#include <nlohmann/json.hpp>
using json = nlohmann::json;

#include <utf8proc.h>

Emitter::Emitter(const std::shared_ptr<SourceMap> &sourceMap, std::ostream &outStream, bool useColor)
    : sourceMap(sourceMap), out(outStream), useColor(useColor)
{
}

void Emitter::emit(const std::shared_ptr<Diagnostic> &diag)
{
    if (diag->isCancelled()) {
        return;
    }
    printHeader(diag);
    printDiagnosticBody(diag);
    if (diag->getNoteMessage()) {
        printNote(diag);
    }
    if (diag->getHelpMessage()) {
        printHelp(diag);
    }
}

void Emitter::printHeader(const std::shared_ptr<Diagnostic> &diag)
{
    auto levelStr = formatLevel(diag->getLevel());
    auto codeStr = formatErrorCode(diag->getLevel(), diag->getCode());
    auto message = format(fmt::emphasis::bold | fg(whiteColor), "{}", diag->getMessage());
    auto colon = format(fmt::emphasis::bold | fg(whiteColor), ":");

    std::string result = fmt::format("{}{}{} {}\n", levelStr, codeStr, colon, message);
    out.write(result.data(), static_cast<std::streamsize>(result.size()));
}

std::string Emitter::formatLevel(Diagnostic::Level level)
{

    switch (level) {
    case Diagnostic::Level::Error:
        return format(fmt::emphasis::bold | fg(redColor), "error");
    case Diagnostic::Level::Warning:
        return format(fmt::emphasis::bold | fg(yellowColor), "warning");
    case Diagnostic::Level::Note:
        return format(fmt::emphasis::bold | fg(cyanColor), "note");
    }

    return "unknown";
}

std::string Emitter::formatErrorCode(Diagnostic::Level level, ErrorCode code)
{
    switch (level) {
    case Diagnostic::Level::Error:
        return format(fmt::emphasis::bold | fg(redColor), "[E{:02d}]", static_cast<int>(code));
    case Diagnostic::Level::Warning:
        return format(fmt::emphasis::bold | fg(yellowColor), "[E{:02d}]", static_cast<int>(code));
    case Diagnostic::Level::Note:
        return format(fmt::emphasis::bold | fg(cyanColor), "[E{:02d}]", static_cast<int>(code));
    }

    return "unknown";
}

void Emitter::printDiagnosticBody(const std::shared_ptr<Diagnostic> &diag)
{
    // Collect all labels
    std::map<std::filesystem::path, std::map<size_t, std::vector<LabelType>>> labelsMapping;

    size_t maxLineNumber = 0;
    // primary label
    const auto &[primarySpan, primaryLabelMsg] = diag->getPrimaryLabel();
    std::filesystem::path primaryFilePath;
    std::size_t primaryLineNumberZeroBased = 0, primaryColumnNumberZeroBased = 0;
    sourceMap->spanToLocation(primarySpan, primaryFilePath, primaryLineNumberZeroBased, primaryColumnNumberZeroBased);
    labelsMapping[primaryFilePath][primaryLineNumberZeroBased] =
        std::vector<LabelType>(1, LabelType(primarySpan, primaryLabelMsg));
    maxLineNumber = std::max(maxLineNumber, primaryLineNumberZeroBased + 1);

    // secondary labels
    for (const auto &[span, labelMsg] : diag->getSecondaryLabels()) {
        std::filesystem::path filePath;
        std::size_t lineNumberZeroBased = 0, columnNumberZeroBased = 0;
        sourceMap->spanToLocation(span, filePath, lineNumberZeroBased, columnNumberZeroBased);
        if (labelsMapping.contains(filePath) && labelsMapping[filePath].contains(lineNumberZeroBased)) {
            labelsMapping[filePath][lineNumberZeroBased].emplace_back(span, labelMsg);
        } else {
            labelsMapping[filePath][lineNumberZeroBased] = std::vector<LabelType>(1, LabelType(span, labelMsg));
        }
        maxLineNumber = std::max(maxLineNumber, lineNumberZeroBased + 1);
    }

    spaceCount = static_cast<size_t>(calculateDisplayWidth(std::to_string(maxLineNumber))) + 1;
    fmt::memory_buffer buffer;
    int primaryLineNumberWidth = calculateDisplayWidth(std::to_string(primaryLineNumberZeroBased + 1));
    // Print the location header
    fmt::format_to(std::back_inserter(buffer), "{}{} {}:{}:{}\n", std::string(spaceCount, ' '),
                   format(fg(cyanColor), "-->"), primaryFilePath.string(), primaryLineNumberZeroBased + 1,
                   primaryColumnNumberZeroBased + 1);

    // print empty line
    fmt::format_to(std::back_inserter(buffer), "{} {}\n", std::string(spaceCount, ' '), format(fg(cyanColor), "|"));

    // print primary string
    auto primarySourceFile = sourceMap->getSourceFile(primaryFilePath);
    std::string primaryLineContent = primarySourceFile->getLine(primaryLineNumberZeroBased);
    fmt::format_to(std::back_inserter(buffer), "{}{} {} {}\n",
                   std::string(spaceCount - static_cast<size_t>(primaryLineNumberWidth), ' '),
                   format(fg(cyanColor), "{}", primaryLineNumberZeroBased + 1), format(fg(cyanColor), "|"),
                   primaryLineContent);

    // print labels in primary string
    printLabelsForLine(buffer, primaryLineContent, primaryLineNumberZeroBased, LabelType(primarySpan, primaryLabelMsg),
                       labelsMapping[primaryFilePath][primaryLineNumberZeroBased], diag->getLevel());

    // print all other lines in primary file
    for (const auto &[lineNumberZeroBased, labels] : labelsMapping[primaryFilePath]) {
        if (lineNumberZeroBased == primaryLineNumberZeroBased) {
            continue;
        }
        // print "..."
        fmt::format_to(std::back_inserter(buffer), "{}{}\n", std::string(spaceCount, ' '),
                       format(fg(cyanColor), "..."));
        // print empty line
        fmt::format_to(std::back_inserter(buffer), "{} {}\n", std::string(spaceCount, ' '), format(fg(cyanColor), "|"));

        // print string
        std::string lineContent = primarySourceFile->getLine(lineNumberZeroBased);
        int lineNumberWidth = calculateDisplayWidth(std::to_string(lineNumberZeroBased + 1));
        fmt::format_to(std::back_inserter(buffer), "{}{} {} {}\n",
                       std::string(spaceCount - static_cast<size_t>(lineNumberWidth), ' '),
                       format(fg(cyanColor), "{}", lineNumberZeroBased + 1), format(fg(cyanColor), "|"), lineContent);
        printLabelsForLine(buffer, lineContent, lineNumberZeroBased, std::nullopt,
                           labelsMapping[primaryFilePath][lineNumberZeroBased], diag->getLevel());
    }

    // print all other files and labels
    for (const auto &[filePath, linesToLabelsMap] : labelsMapping) {
        if (filePath == primaryFilePath) {
            continue;
        }
        // print location
        // print all lines
        // TODO: finish this
        fmt::format_to(std::back_inserter(buffer), "{}\n",
                       format(fg(redColor), "Labels in different files not implemented!"));
    }

    out.write(buffer.data(), static_cast<std::streamsize>(buffer.size()));
}

int Emitter::calculateDisplayWidth(const std::string &text)
{
    int width = 0;
    const char *str = text.c_str();
    auto len = static_cast<utf8proc_ssize_t>(text.size());
    utf8proc_ssize_t idx = 0;
    utf8proc_int32_t codepoint = 0;
    while (idx < len) {
        utf8proc_ssize_t charLen =
            utf8proc_iterate(reinterpret_cast<const utf8proc_uint8_t *>(str + idx), len - idx, &codepoint);
        if (charLen <= 0) {
            LOG_DETAILED_ERROR("Invalid utf-8 formatting in calculateDisplayWidth");
            break;
        }

        width += utf8proc_charwidth(codepoint);
        idx += charLen;
    }
    return width;
}

int Emitter::calculateCodePoints(const std::string &text)
{
    int codePoints = 0;
    const char *str = text.c_str();
    auto len = static_cast<utf8proc_ssize_t>(text.size());
    utf8proc_ssize_t idx = 0;
    utf8proc_int32_t codepoint = 0;
    while (idx < len) {
        utf8proc_ssize_t charLen =
            utf8proc_iterate(reinterpret_cast<const utf8proc_uint8_t *>(str + idx), len - idx, &codepoint);
        if (charLen <= 0) {
            LOG_DETAILED_ERROR("Invalid utf-8 formatting in calculateCodePoints");
            break;
        }
        idx += charLen;
        codePoints += static_cast<int>(charLen);
    }
    return codePoints;
}

void Emitter::printLabelsForLine(fmt::memory_buffer &buffer, const std::string &lineContent, size_t lineNumberZeroBased,
                                 const std::optional<LabelType> &primaryLabel, std::vector<LabelType> &labels,
                                 Diagnostic::Level level)
{
    fmt::rgb primaryColor;
    switch (level) {
    case Diagnostic::Level::Error:
        primaryColor = redColor;
        break;
    case Diagnostic::Level::Warning:
        primaryColor = yellowColor;
        break;
    case Diagnostic::Level::Note:
        primaryColor = cyanColor;
        break;
    }

    // Initialize a marker line
    // + 1 needed if we are underlining the '\n' (it's not included in the lineContent)
    std::string markerLine(static_cast<size_t>(calculateDisplayWidth(lineContent)) + 1, ' ');

    // Vector to hold messages that need to be printed under the marker line
    std::vector<std::tuple<size_t, std::string, bool>> labelMessagesToPrint;
    // Label Message to print on the same line
    std::string labelMessageToAdd;

    // Sort in the descneding order
    std::sort(labels.begin(), labels.end(), [](auto a, auto b) { return a > b; });

    // Apply labels to the marker line
    for (const auto &[span, labelMsg] : labels) {
        std::filesystem::path filePath;
        std::size_t startLine = 0, startColumn = 0, endLine = 0, endColumn = 0;
        sourceMap->spanToStartPosition(span, filePath, startLine, startColumn);
        sourceMap->spanToEndPosition(span, filePath, endLine, endColumn);

        if (startLine != lineNumberZeroBased || endLine != lineNumberZeroBased) {
            LOG_DETAILED_ERROR("In printLabelsForLine label span isn't the same as specified");
            return;
        }

        // Adjust for UTF-8 characters
        auto startPos = static_cast<size_t>(calculateDisplayWidth(lineContent.substr(0, startColumn)));
        auto endPos = static_cast<size_t>(calculateDisplayWidth(lineContent.substr(0, endColumn)));

        char markerChar = '-';
        bool isPrimaryLabel = primaryLabel && primaryLabel.value().first == span;
        if (isPrimaryLabel) {
            markerChar = '^';
        }

        // Fill in the markers
        for (size_t i = startPos; i < endPos && i < markerLine.size(); ++i) {
            markerLine[i] = markerChar;
        }

        // '\n' has empty width, need to handle separately
        if (startPos == endPos && startPos < markerLine.size()) {
            markerLine[startPos] = markerChar;
        }

        // Handle label messages
        if (!labelMsg.empty()) {
            // Append the message after the markers if it's the first from the right and it's the primary
            if (labels[0].first == span && isPrimaryLabel) {
                labelMessageToAdd = " " + labelMsg;
            } else {
                labelMessagesToPrint.emplace_back(startPos, labelMsg, isPrimaryLabel);
            }
        }
    }

    // trim trailing spaces from markerLine
    // Find the last non-space character
    auto it = std::find_if(markerLine.rbegin(), markerLine.rend(), [](char ch) { return !std::isspace(ch); });
    // Erase the trailing spaces
    markerLine.erase(it.base(), markerLine.end());

    // Print the marker line with appropriate color
    std::string coloredMarkerLine;
    for (char c : markerLine) {
        if (c == '^') {
            // Color primary markers red
            coloredMarkerLine += format(fmt::emphasis::bold | fg(primaryColor), "{}", c);
        } else if (c == '-') {
            // Color secondary markers cyan
            coloredMarkerLine += format(fmt::emphasis::bold | fg(cyanColor), "{}", c);
        } else if (c == ' ') {
            // Keep spaces
            coloredMarkerLine += c;
        }
    }

    if (!labelMessageToAdd.empty()) {
        coloredMarkerLine += format(fg(primaryColor), "{}", labelMessageToAdd);
    }

    fmt::format_to(std::back_inserter(buffer), "{} {} {}\n", std::string(spaceCount, ' '), format(fg(cyanColor), "|"),
                   coloredMarkerLine);

    if (labelMessagesToPrint.empty()) {
        return;
    }

    // Now print any label messages that didn't fit on the marker line
    // first print initial line of | | | ...
    {
        const auto &[currentStartPos, currentLabelMsg, currentIsPrimaryLabel] = labelMessagesToPrint[0];
        const size_t lineLength = currentStartPos + 1;
        std::string messageLine(lineLength, ' ');

        std::optional<size_t> primaryLabelIndex;
        for (const auto &[startPos, _, isPrimaryLabel] : labelMessagesToPrint) {
            if (startPos > currentStartPos) {
                continue;
            }
            messageLine[startPos] = '|';
            if (isPrimaryLabel) {
                primaryLabelIndex = startPos;
            }
        }

        std::string coloredLine;
        for (size_t i = 0; i < messageLine.size(); ++i) {
            const char c = messageLine[i];
            if (c == '|') {
                if (primaryLabelIndex && primaryLabelIndex == i) {
                    coloredLine += format(fg(primaryColor), "{}", "|");
                } else {
                    coloredLine += format(fg(cyanColor), "{}", "|");
                }
            } else {
                coloredLine += c;
            }
        }
        fmt::format_to(std::back_inserter(buffer), "{} {} {}\n", std::string(spaceCount, ' '),
                       format(fg(cyanColor), "|"), coloredLine);
    }

    // then print all the messages
    for (const auto &[currentStartPos, currentLabelMsg, currentIsPrimaryLabel] : labelMessagesToPrint) {
        // + 1 isn't needed, because last can't be a |
        size_t lineLength = currentStartPos;
        std::string messageLine(lineLength, ' ');

        std::optional<size_t> primaryLabelIndex;
        for (const auto &[startPos, _, isPrimaryLabel] : labelMessagesToPrint) {
            if (startPos >= currentStartPos) {
                continue;
            }
            messageLine[startPos] = '|';
            if (isPrimaryLabel) {
                primaryLabelIndex = startPos;
            }
        }
        std::string coloredLine;
        for (size_t i = 0; i < messageLine.size(); ++i) {
            char c = messageLine[i];
            if (c == '|') {
                if (primaryLabelIndex && primaryLabelIndex == i) {
                    coloredLine += format(fg(primaryColor), "{}", "|");
                } else {
                    coloredLine += format(fg(cyanColor), "{}", "|");
                }
            } else {
                coloredLine += c;
            }
        }
        std::string labelMessage = currentLabelMsg;
        if (currentIsPrimaryLabel) {
            coloredLine += format(fg(primaryColor), "{}", labelMessage);
        } else {
            coloredLine += format(fg(cyanColor), "{}", labelMessage);
        }

        fmt::format_to(std::back_inserter(buffer), "{} {} {}\n", std::string(spaceCount, ' '),
                       format(fg(cyanColor), "|"), coloredLine);
    }
}

void Emitter::printNote(const std::shared_ptr<Diagnostic> &diag)
{
    auto noteMessage = diag->getNoteMessage();
    if (!noteMessage) {
        return;
    }
    std::string result = fmt::format("{} {} {}: {}\n", std::string(spaceCount, ' '), format(fg(cyanColor), "="),
                                     format(fg(whiteColor) | fmt::emphasis::bold, "note"), noteMessage.value());

    out.write(result.data(), static_cast<std::streamsize>(result.size()));
}

void Emitter::printHelp(const std::shared_ptr<Diagnostic> & /*diag*/) {}

void Emitter::emitJSON(const std::vector<std::shared_ptr<Diagnostic>> &diagnostics)
{
    nlohmann::json output = nlohmann::json::array();

    for (const auto &diag : diagnostics) {
        nlohmann::json diagJson;

        diagJson["message"] = diag->getMessage();
        diagJson["severity"] = diag->getLevel() == Diagnostic::Level::Error     ? "Error"
                               : diag->getLevel() == Diagnostic::Level::Warning ? "Warning"
                                                                                : "Info";
        diagJson["code"] = static_cast<int>(diag->getCode());
        auto noteMessage = diag->getNoteMessage();
        if (noteMessage) {
            diagJson["note_message"] = noteMessage.value();
        } else {
            diagJson["note_message"] = "";
        }

        // Primary label
        const auto &primaryLabel = diag->getPrimaryLabel();
        nlohmann::json primaryLabelJson;

        std::filesystem::path filePath;
        std::size_t lineStart = 0, characterStart = 0;
        sourceMap->spanToLocation(primaryLabel.first, filePath, lineStart, characterStart);

        std::size_t lineEnd = 0, characterEnd = 0;
        sourceMap->spanToEndLocation(primaryLabel.first, filePath, lineEnd, characterEnd);

        primaryLabelJson["span"]["start"]["line"] = lineStart;
        primaryLabelJson["span"]["start"]["character"] = characterStart;
        primaryLabelJson["span"]["end"]["line"] = lineEnd;
        primaryLabelJson["span"]["end"]["character"] = characterEnd;
        primaryLabelJson["message"] = primaryLabel.second;
        diagJson["primaryLabel"] = primaryLabelJson;

        // Secondary labels
        nlohmann::json secondaryLabelsJson = nlohmann::json::array();
        for (const auto &secondaryLabel : diag->getSecondaryLabels()) {
            nlohmann::json secondaryLabelJson;

            sourceMap->spanToLocation(secondaryLabel.first, filePath, lineStart, characterStart);
            sourceMap->spanToEndLocation(secondaryLabel.first, filePath, lineEnd, characterEnd);

            secondaryLabelJson["span"]["start"]["line"] = lineStart;
            secondaryLabelJson["span"]["start"]["character"] = characterStart;
            secondaryLabelJson["span"]["end"]["line"] = lineEnd;
            secondaryLabelJson["span"]["end"]["character"] = characterEnd;
            secondaryLabelJson["message"] = secondaryLabel.second;
            secondaryLabelsJson.push_back(secondaryLabelJson);
        }
        diagJson["secondaryLabels"] = secondaryLabelsJson;

        output.push_back(diagJson);
    }

    std::string result = output.dump(2);
    out.write(result.data(), static_cast<std::streamsize>(result.size()));
}

void Emitter::spanToLineChar(const Span &span, int &startLine, int &startChar, int &endLine, int &endChar) const
{
    std::filesystem::path filePath;
    std::size_t lineNumberZeroBased = 0, columnNumberZeroBased = 0;

    sourceMap->spanToLocation(span, filePath, lineNumberZeroBased, columnNumberZeroBased);
    startLine = static_cast<int>(lineNumberZeroBased);
    startChar = static_cast<int>(columnNumberZeroBased);
    sourceMap->spanToEndLocation(span, filePath, lineNumberZeroBased, columnNumberZeroBased);
    endLine = static_cast<int>(lineNumberZeroBased);
    endChar = static_cast<int>(columnNumberZeroBased);

    // startChar = static_cast<int>(columnNumberZeroBased);

    // auto sourceFile = sourceMap->lookupSourceFile(span.lo);
    // if (sourceFile) {
    //     std::string lineContent = sourceFile->getLine(lineNumberZeroBased);
    //     std::size_t lineStartByte = sourceFile->getLineStart(lineNumberZeroBased);
    //     std::size_t byteOffsetInLine = span.lo - lineStartByte;
    //     std::size_t byteLength = span.hi - span.lo;
    //     std::string underlineText = lineContent.substr(byteOffsetInLine, byteLength);
    //     endChar = startChar + calculateCodePoints(underlineText) + 1;
    // }
}
File emitter.h:

#pragma once

#include "source_map.h"
#include "diagnostic.h"

#include <memory>
#include <ostream>
#include <iostream>
#include <fmt/color.h>

using LabelType = std::pair<Span, std::string>;

class Emitter {
public:
    explicit Emitter(const std::shared_ptr<SourceMap> &sourceMap, std::ostream &outStream = std::cout,
                     bool useColor = true);

    void emit(const std::shared_ptr<Diagnostic> &diag);
    void emitJSON(const std::vector<std::shared_ptr<Diagnostic>> &diagnostics);

private:
    std::shared_ptr<SourceMap> sourceMap;
    std::ostream &out;
    bool useColor;
    fmt::rgb whiteColor = fmt::rgb(200, 200, 200);
    fmt::rgb redColor = fmt::rgb(254, 89, 89);
    fmt::rgb yellowColor = fmt::rgb(255, 191, 0);
    fmt::rgb cyanColor = fmt::rgb(0, 200, 200);
    size_t spaceCount = 0;

    template <typename... Args>
    std::string format(const fmt::text_style &ts, fmt::format_string<Args...> fmt_str, Args &&...args)
    {
        return fmt::format(useColor ? ts : fmt::text_style(), fmt_str, std::forward<Args>(args)...);
    }

    void printHeader(const std::shared_ptr<Diagnostic> &diag);
    void printDiagnosticBody(const std::shared_ptr<Diagnostic> &diag);
    void printNote(const std::shared_ptr<Diagnostic> &diag);
    void printHelp(const std::shared_ptr<Diagnostic> &diag);
    void printLabelsForLine(fmt::memory_buffer &buffer, const std::string &lineContent, size_t lineNumberZeroBased,
                            const std::optional<LabelType> &primaryLabel, std::vector<LabelType> &labels,
                            Diagnostic::Level level);

    std::string formatLevel(Diagnostic::Level level);
    std::string formatErrorCode(Diagnostic::Level level, ErrorCode code);
    int calculateDisplayWidth(const std::string &text);
    int calculateCodePoints(const std::string &text);
    void spanToLineChar(const Span &span, int &startLine, int &startChar, int &endLine, int &endChar) const;
};

File error_codes.h:

#pragma once

enum class ErrorCode : std::uint8_t {
#define DEFINE_ERROR(code, message) code,
#define DEFINE_WARNING(code, message) code,
#include "diagnostic_messages.def"
#undef DEFINE_ERROR
#undef DEFINE_WARNING
};

File log.h:

#pragma once

// Regular logging macros
// #define LOG_TRACE(...) Log::get_core_logger()->trace(__VA_ARGS__)
// #define LOG_INFO(...) Log::get_core_logger()->info(__VA_ARGS__)
// #define LOG_WARN(...) Log::get_core_logger()->warn(__VA_ARGS__)
// #define LOG_ERROR(...) Log::get_core_logger()->error(__VA_ARGS__)

// // Detailed logging macros
// #if defined(__clang__)
// #    define PRETTY_FUNCTION __PRETTY_FUNCTION__
// #elif defined(__GNUC__) || defined(__GNUG__)
// #    define PRETTY_FUNCTION __PRETTY_FUNCTION__
// #elif defined(_MSC_VER)
// #    define PRETTY_FUNCTION __FUNCSIG__
// #else
// #    define PRETTY_FUNCTION __func__
// #endif

// #define LOG_FORMAT_DETAILED(message, file, line, function) "[{}:{} ({})] {}", file, line, function, message

// #define LOG_DETAILED_TRACE(...)                                                                                        \
//     Log::get_core_logger()->trace(LOG_FORMAT_DETAILED(fmt::format(__VA_ARGS__), __FILE__, __LINE__, PRETTY_FUNCTION))
// #define LOG_DETAILED_INFO(...)                                                                                         \
//     Log::get_core_logger()->info(LOG_FORMAT_DETAILED(fmt::format(__VA_ARGS__), __FILE__, __LINE__, PRETTY_FUNCTION))
// #define LOG_DETAILED_WARN(...)                                                                                         \
//     Log::get_core_logger()->warn(LOG_FORMAT_DETAILED(fmt::format(__VA_ARGS__), __FILE__, __LINE__, PRETTY_FUNCTION))
// #define LOG_DETAILED_ERROR(...)                                                                                        \
//     Log::get_core_logger()->error(LOG_FORMAT_DETAILED(fmt::format(__VA_ARGS__), __FILE__, __LINE__, PRETTY_FUNCTION))
#include <fmt/core.h>
#include <fmt/color.h>

#if defined(__GNUC__) || defined(__clang__)
#    define PRETTY_FUNCTION __PRETTY_FUNCTION__
#elif defined(_MSC_VER)
#    define PRETTY_FUNCTION __FUNCSIG__
#else
#    define PRETTY_FUNCTION __func__
#endif

#define LOG_DETAILED_ERROR(...)                                                                                        \
    fmt::print(stderr, "{} {} ({}:{}): {}\n", fmt::format(fg(fmt::color::red), "[ERROR]"), __FILE__, __LINE__,         \
               PRETTY_FUNCTION, fmt::format(__VA_ARGS__));

File main.cpp:

#include "log.h"
#include "preprocessor.h"
#include "symbol_table.h"
#include "parser.h"
#include "session.h"
#include "error_codes.h"
#include "ast.h"
#include "semantic_analyzer.h"
#include "tokenize.h"

#include <iostream>
#include <memory>
#include <fmt/core.h>
#include <filesystem>

#ifdef _WIN32
#    include <windows.h>
#    include <io.h>
#    include <fcntl.h>
#endif

void setupConsoleForUtf8()
{
#ifdef _WIN32
    // Set console output code page to UTF-8 on Windows
    SetConsoleOutputCP(CP_UTF8);
#endif
}

int main(int argc, char *argv[])
{
    setupConsoleForUtf8();

    std::filesystem::path filename = "examples/test1.asm";
    bool jsonOutput = false;
    bool readFromStdin = false;
    for (int i = 1; i < argc; ++i) {
        if (std::string(argv[i]) == "--json") {
            jsonOutput = true;
        } else if (std::string(argv[i]) == "--stdin") {
            readFromStdin = true;
        } else {
            filename = std::string(argv[i]);
        }
    }
    // TODO: Remove in release
    std::filesystem::path new_path = R"(C:\Users\grigo\Documents\MasmLint)";
    std::filesystem::current_path(new_path);

    auto parseSess = std::make_shared<ParseSession>();
    std::shared_ptr<SourceFile> sourceFile;
    if (readFromStdin) {
#ifdef _WIN32
        _setmode(_fileno(stdin), _O_BINARY);
#endif
        std::string sourceContent;
        sourceContent.assign(std::istreambuf_iterator<char>(std::cin), std::istreambuf_iterator<char>());
        // turn of the hack for json, because vscode can underline EOF
        if (!jsonOutput) {
            sourceContent += "\n"; // hack for not having to underline EOF
        }
        sourceFile = parseSess->sourceMap->newSourceFile(filename, sourceContent);
    } else {
        sourceFile = parseSess->sourceMap->loadFile(filename);
    }

    if (sourceFile) {
        Tokenizer tokenizer(parseSess, sourceFile->getSource());
        std::vector<Token> tokens = tokenizer.tokenize();

        Preprocessor preprocessor(parseSess, tokens);
        std::vector<Token> preprocessedTokens = preprocessor.preprocess();

        Parser parser(parseSess, preprocessedTokens);
        ASTPtr ast = parser.parse();

        SemanticAnalyzer semanticAnalyzer(parseSess, ast);
        // add step for creating a symbol table
        semanticAnalyzer.analyze();

        if (!jsonOutput) {
            printAST(ast, 0);
            std::cout << "\n";
            parseSess->symbolTable->printSymbols();
        }
    } else {
        Diagnostic diag(Diagnostic::Level::Error, ErrorCode::FAILED_TO_OPEN_FILE, filename.string());
        parseSess->dcx->addDiagnostic(diag);
    }

    if (parseSess->dcx->hasErrors()) {
        if (jsonOutput) {
            parseSess->dcx->emitJsonDiagnostics();

        } else {
            parseSess->dcx->emitDiagnostics();
        }
    } else {
        if (jsonOutput) {
            fmt::print("[]");
        } else {
            fmt::print("Parsing completed successfully with no errors.\n");
        }
    }
    return 0;
}

File parser.cpp:

#include "parser.h"
#include "symbol_table.h"
#include "diag_ctxt.h"
#include "log.h"
#include "symbol_table.h"

#include <ranges>
#include <unordered_set>

// #include <fmt/core.h>

static const std::unordered_set<std::string> dataDirectives = {"DB", "DW", "DD", "DQ"};

Parser::Parser(const std::shared_ptr<ParseSession> &parseSession, const std::vector<Token> &tokens)
    : parseSess(parseSession), tokens(tokens), currentToken(tokens[currentIndex])
{
}

// Only advance when matched a not EndOfFile
void Parser::advance()
{
    if (currentToken.type == TokenType::EndOfFile) {
        LOG_DETAILED_ERROR("Trying to advance() after EndOfFile encountered!");
        return;
    }
    currentToken = tokens[++currentIndex];
}

void Parser::synchronize()
{
    while (!match(TokenType::EndOfLine) && !match(TokenType::EndOfFile)) {
        advance();
    }
}

bool Parser::match(TokenType type) const { return currentToken.type == type; }

bool Parser::match(const std::string &value) const { return stringToUpper(currentToken.lexeme) == value; }

bool Parser::match(const std::unordered_set<std::string> &values) const { return values.contains(stringToUpper(currentToken.lexeme)); }

bool Parser::match(TokenType type, const std::string &value) const
{
    return currentToken.type == type && stringToUpper(currentToken.lexeme) == value;
}

// Can't consume EndOfFile
std::optional<Token> Parser::consume(TokenType type)
{
    if (currentToken.type == type) {
        Token token = currentToken;
        advance();
        return token;
    } else {
        return std::nullopt;
    }
}
// Can't consume EndOfFile
std::optional<Token> Parser::consume(const std::string &value)
{
    if (stringToUpper(currentToken.lexeme) == value) {
        Token token = currentToken;
        advance();
        return token;
    } else {
        return std::nullopt;
    }
}

bool Parser::lookaheadMatch(size_t n, const std::string &value) const
{
    if (currentIndex + n < tokens.size()) {
        return stringToUpper(tokens[currentIndex + n].lexeme) == value;
    } else {
        return stringToUpper(tokens.back().lexeme) == value;
    }
}

bool Parser::lookaheadMatch(size_t n, const std::unordered_set<std::string> &values) const
{
    if (currentIndex + n < tokens.size()) {
        return values.contains(stringToUpper(tokens[currentIndex + n].lexeme));
    } else {
        return values.contains(stringToUpper(tokens.back().lexeme));
    }
}

bool Parser::lookaheadNextLineMatch(const std::string &value) const
{
    size_t tempIndex = currentIndex;

    while (tempIndex < tokens.size() && tokens[tempIndex].type != TokenType::EndOfLine) {
        ++tempIndex;
    }
    if (tempIndex + 1 < tokens.size()) {
        return stringToUpper(tokens[tempIndex + 1].lexeme) == value;
    } else {
        return stringToUpper(tokens.back().lexeme) == value;
    }
}

bool Parser::lookaheadMatch(size_t n, TokenType type) const
{
    if (currentIndex + n < tokens.size()) {
        return tokens[currentIndex + n].type == type;
    } else {
        return tokens.back().type == type;
    }
}

ASTPtr Parser::parse()
{
    std::vector<std::shared_ptr<Statement>> statements;
    std::shared_ptr<Directive> endDir;
    currentIndex = 0;
    currentToken = tokens[currentIndex];
    while (!match("END") && !match(TokenType::EndOfFile)) {
        if (!match(TokenType::EndOfLine) && !match(TokenType::EndOfFile)) {
            std::shared_ptr<Statement> statement;
            statement = parseStatement();
            if (INVALID(statement)) {
                synchronize();
            } else {
                // remove and handle everyhting in parseStatement()?
                if (!match(TokenType::EndOfLine) && !match(TokenType::EndOfFile)) {
                    std::ignore = reportExpectedEndOfLine(currentToken);
                    synchronize();
                    // continue parsing after synchronize
                }
            }

            // Can't consume endoffile
            if (match(TokenType::EndOfLine)) {
                consume(TokenType::EndOfLine);
            }
            statements.push_back(statement);
        } else {
            // empty line
            if (match(TokenType::EndOfLine)) {
                consume(TokenType::EndOfLine);
            }
        }
    }
    if (match("END")) {
        endDir = parseEndDir();
    } else {
        std::ignore = reportExpectedEndDir(currentToken);
    }
    return std::make_shared<Program>(statements, endDir);
}

std::shared_ptr<Statement> Parser::parseStatement()
{
    if (match(".CODE") || match(".DATA") || match(".STACK")) {
        // not set cursegment when parseSegDir is not successfull?
        if (match(".CODE")) {
            currentSegment = ".CODE";
        } else if (match(".DATA")) {
            currentSegment = ".DATA";
        }
        return parseSegDir();
    }
    if (match("STRUC")) {
        auto diag = reportExpectedIdentifierBeforeStruc(currentToken);
        return INVALID_STATEMENT(diag);
    } else if (match("RECORD")) {
        auto diag = reportExpectedIdentifierBeforeRecord(currentToken);
        return INVALID_STATEMENT(diag);
    } else if (match("PROC")) {
        auto diag = reportExpectedIdentifierBeforeProc(currentToken);
        return INVALID_STATEMENT(diag);
    } else if (match("EQU")) {
        auto diag = reportExpectedIdentifierBeforeEqu(currentToken);
        return INVALID_STATEMENT(diag);
    } else if (match("=")) {
        auto diag = reportExpectedIdentifierBeforeEqual(currentToken);
        return INVALID_STATEMENT(diag);
    }

    if (lookaheadMatch(1, "STRUC")) {
        return parseStructDir();
    } else if (lookaheadMatch(1, "PROC")) {
        return parseProcDir();
    } else if (lookaheadMatch(1, "RECORD")) {
        return parseRecordDir();
    } else if (lookaheadMatch(1, "EQU")) {
        return parseEquDir();
    } else if (lookaheadMatch(1, "=")) {
        return parseEqualDir();
    } else {
        if (currentSegment) {
            if (currentSegment.value() == ".DATA") {
                return parseDataDir();
            } else {
                return parseInstruction();
            }
        } else {
            // TODO: change?
            Token firstToken = currentToken;
            while (!match(TokenType::EndOfLine) && !match(TokenType::EndOfFile)) {
                advance();
            }
            Token lastToken = currentToken;
            auto diag = reportMustBeInSegmentBlock(firstToken, lastToken);
            return INVALID_STATEMENT(diag);
        }
    }
}

std::shared_ptr<SegDir> Parser::parseSegDir()
{
    if (!match(".CODE") && !match(".DATA") && !match(".STACK")) {
        LOG_DETAILED_ERROR("shouldn't happen");
        return INVALID_SEG_DIR(std::nullopt);
    }
    Token directiveToken = currentToken;
    std::optional<ExpressionPtr> expression;
    consume(TokenType::Directive);
    if (stringToUpper(directiveToken.lexeme) == ".STACK") {
        ExpressionPtr expr = parseExpression();
        if (INVALID(expr)) {
            return INVALID_SEG_DIR(expr->diagnostic);
        }
    }
    return std::make_shared<SegDir>(directiveToken, expression);
}

std::shared_ptr<DataDir> Parser::parseDataDir(const std::optional<Token> &strucNameToken)
{
    std::optional<Token> idToken;
    // TODO: debug and test this
    if (match(dataDirectives)) {
        idToken = std::nullopt;
    } else if (false) {
        // TODO: check whether first symbol is defined as STRUC or RECORD?
    } else if ((lookaheadMatch(1, dataDirectives) ||
                lookaheadMatch(1, TokenType::Identifier) /* TODO: check that this identifier is defined STRUC or RECORD?*/)) {
        idToken = currentToken;
        if (!match(TokenType::Identifier)) {
            auto diag = reportExpectedIdentifierInDataDir(currentToken);
            return INVALID_DATA_DIR(diag);
        }
        consume(TokenType::Identifier);
        if (strucNameToken) {
            std::string fieldName = idToken.value().lexeme;
            std::shared_ptr<Symbol> symbol = parseSess->symbolTable->findSymbol(strucNameToken.value());
            auto structSymbol = std::dynamic_pointer_cast<StructSymbol>(symbol);
            if (structSymbol->namedFields.contains(fieldName)) {
                auto diag = reportSymbolRedefinition(idToken.value(), structSymbol->namedFields[fieldName]->token);
                return INVALID_DATA_DIR(diag);
            }
        } else {
            if (auto symbolPtr = parseSess->symbolTable->findSymbol(idToken.value())) {
                auto diag = reportSymbolRedefinition(idToken.value(), symbolPtr->token);
                return INVALID_DATA_DIR(diag);
            }
        }
    }
    std::shared_ptr<DataItem> dataItem = parseDataItem(idToken, strucNameToken);
    if (INVALID(dataItem)) {
        return INVALID_DATA_DIR(dataItem->diagnostic);
    }
    return std::make_shared<DataDir>(idToken, dataItem);
}

std::shared_ptr<StructDir> Parser::parseStructDir()
{
    Token firstIdToken, secondIdToken;
    Token directiveToken, endsDirToken;
    std::vector<std::shared_ptr<DataDir>> fields;
    if (!match(TokenType::Identifier)) {
        auto diag = reportExpectedIdentifierInStrucDir(currentToken);
        return INVALID_STRUCT_DIR(diag);
    }
    firstIdToken = currentToken;
    consume(TokenType::Identifier);
    if (auto symbolPtr = parseSess->symbolTable->findSymbol(firstIdToken)) {
        auto diag = reportSymbolRedefinition(firstIdToken, symbolPtr->token);
        return INVALID_STRUCT_DIR(diag);
    }
    parseSess->symbolTable->addSymbol(std::make_shared<StructSymbol>(firstIdToken));
    if (!match("STRUC")) {
        LOG_DETAILED_ERROR("shouldn't happen");
        return INVALID_STRUCT_DIR(std::nullopt);
    }
    directiveToken = currentToken;
    consume("STRUC");
    if (!match(TokenType::EndOfLine)) {
        auto diag = reportExpectedEndOfLine(currentToken);
        return INVALID_STRUCT_DIR(diag);
    }
    consume(TokenType::EndOfLine);

    while (!match("ENDS") && !lookaheadMatch(1, "ENDS") && !match(TokenType::EndOfFile)) {
        if (!match(TokenType::EndOfLine) && !match(TokenType::EndOfFile)) {
            std::shared_ptr<DataDir> dataDir;
            dataDir = parseDataDir(firstIdToken);
            if (INVALID(dataDir)) {
                synchronize();
            } else {
                // remove and handle everyhting in parseStatement()?
                if (!match(TokenType::EndOfLine) && !match(TokenType::EndOfFile)) {
                    std::ignore = reportExpectedEndOfLine(currentToken);
                    synchronize();
                    // continue parsing after synchronize
                }
            }

            // Can't consume endoffile
            if (match(TokenType::EndOfLine)) {
                consume(TokenType::EndOfLine);
            }

            fields.push_back(dataDir);

        } else {
            // empty line
            if (match(TokenType::EndOfLine)) {
                consume(TokenType::EndOfLine);
            }
        }
    }
    if (match("ENDS")) {
        auto diag = reportMissingIdentifierBeforeEnds(currentToken);
        return INVALID_STRUCT_DIR(diag);
    }

    // parse ENDS
    if (!lookaheadMatch(1, "ENDS")) {
        auto diag = reportExpectedEnds(currentToken);
        return INVALID_STRUCT_DIR(diag);
    }
    if (currentToken.lexeme != firstIdToken.lexeme) {
        auto diag = reportExpectedDifferentIdentifierInStructDir(currentToken, firstIdToken);
        return INVALID_STRUCT_DIR(diag);
    }

    secondIdToken = currentToken;
    consume(TokenType::Identifier);
    if (!match("ENDS")) {
        LOG_DETAILED_ERROR("shouldn't happen");
        return INVALID_STRUCT_DIR(std::nullopt);
    }
    endsDirToken = currentToken;
    consume("ENDS");
    return std::make_shared<StructDir>(firstIdToken, directiveToken, fields, secondIdToken, endsDirToken);
}

std::shared_ptr<RecordDir> Parser::parseRecordDir()
{
    Token idToken, directiveToken;
    std::vector<std::shared_ptr<RecordField>> fields;
    if (!match(TokenType::Identifier)) {
        auto diag = reportExpectedIdentifierInRecordDir(currentToken);
        return INVALID_RECORD_DIR(diag);
    }
    idToken = currentToken;
    consume(TokenType::Identifier);
    if (auto symbolPtr = parseSess->symbolTable->findSymbol(idToken)) {
        auto diag = reportSymbolRedefinition(idToken, symbolPtr->token);
        return INVALID_RECORD_DIR(diag);
    }

    if (!match("RECORD")) {
        LOG_DETAILED_ERROR("shouldn't happen");
        return INVALID_RECORD_DIR(std::nullopt);
    }
    directiveToken = currentToken;
    consume("RECORD");

    std::shared_ptr<RecordField> field = parseRecordField();
    if (INVALID(field)) {
        return INVALID_RECORD_DIR(field->diagnostic);
    }
    fields.push_back(field);

    while (match(",")) {
        advance();
        field = parseRecordField();
        if (INVALID(field)) {
            return INVALID_RECORD_DIR(field->diagnostic);
        }
        fields.push_back(field);
    }

    if (!match(TokenType::EndOfLine) && !match(TokenType::EndOfFile)) {
        auto diag = reportExpectedCommaOrEndOfLine(currentToken);
        return INVALID_RECORD_DIR(diag);
    }
    auto recordDir = std::make_shared<RecordDir>(idToken, directiveToken, fields);
    parseSess->symbolTable->addSymbol(std::make_shared<RecordSymbol>(idToken, recordDir));

    return recordDir;
}

std::shared_ptr<RecordField> Parser::parseRecordField()
{
    if (!match(TokenType::Identifier)) {
        auto diag = reportExpectedIdentifierInRecordDir(currentToken);
        return INVALID_RECORD_FIELD(diag);
    }
    Token fieldToken = currentToken;
    advance();
    if (auto symbolPtr = parseSess->symbolTable->findSymbol(fieldToken)) {
        auto diag = reportSymbolRedefinition(fieldToken, symbolPtr->token);
        return INVALID_RECORD_FIELD(diag);
    }

    if (!match(":")) {
        auto diag = reportExpectedColonInRecordField(currentToken);
        return INVALID_RECORD_FIELD(diag);
    }
    advance();
    ExpressionPtr width = parseExpression();
    if (INVALID(width)) {
        return INVALID_RECORD_FIELD(width->diagnostic);
    }
    std::optional<ExpressionPtr> initialValue;
    if (match("=")) {
        advance();
        ExpressionPtr initial = parseExpression();
        if (INVALID(initial)) {
            return INVALID_RECORD_FIELD(initial->diagnostic);
        }
        initialValue = initial;
    }
    auto recordField = std::make_shared<RecordField>(fieldToken, width, initialValue);
    parseSess->symbolTable->addSymbol(std::make_shared<RecordFieldSymbol>(fieldToken, recordField));

    return recordField;
}

std::shared_ptr<ProcDir> Parser::parseProcDir()
{
    Token firstIdToken, secondIdToken;
    Token directiveToken, endpDirToken;
    std::vector<std::shared_ptr<Instruction>> fields;
    if (!match(TokenType::Identifier)) {
        auto diag = reportExpectedIdentifierInProcDir(currentToken);
        return INVALID_PROC_DIR(diag);
    }
    firstIdToken = currentToken;
    consume(TokenType::Identifier);
    if (auto symbolPtr = parseSess->symbolTable->findSymbol(firstIdToken)) {
        auto diag = reportSymbolRedefinition(firstIdToken, symbolPtr->token);
        return INVALID_PROC_DIR(diag);
    }
    parseSess->symbolTable->addSymbol(std::make_shared<ProcSymbol>(firstIdToken));

    if (!match("PROC")) {
        LOG_DETAILED_ERROR("shouldn't happen");
        return INVALID_PROC_DIR(std::nullopt);
    }
    directiveToken = currentToken;
    consume("PROC");
    if (!match(TokenType::EndOfLine)) {
        auto diag = reportExpectedEndOfLine(currentToken);
        return INVALID_PROC_DIR(diag);
    }
    consume(TokenType::EndOfLine);

    while (!match("ENDP") && !lookaheadMatch(1, "ENDP") && !match(TokenType::EndOfFile)) {
        if (!match(TokenType::EndOfLine) && !match(TokenType::EndOfFile)) {
            std::shared_ptr<Instruction> instruction;
            instruction = parseInstruction();
            if (INVALID(instruction)) {
                synchronize();
            } else {
                if (!match(TokenType::EndOfLine) && !match(TokenType::EndOfFile)) {
                    std::ignore = reportExpectedEndOfLine(currentToken);
                    synchronize();
                    // continue parsing after synchronize
                }
            }

            // Can't consume endoffile
            if (match(TokenType::EndOfLine)) {
                consume(TokenType::EndOfLine);
            }

            fields.push_back(instruction);

        } else {
            // empty line
            if (match(TokenType::EndOfLine)) {
                consume(TokenType::EndOfLine);
            }
        }
    }
    if (match("ENDP")) {
        auto diag = reportMissingIdentifierBeforeEndp(currentToken);
        return INVALID_PROC_DIR(diag);
    }

    // parse ENDP
    if (!lookaheadMatch(1, "ENDP")) {
        auto diag = reportExpectedEndp(currentToken);
        return INVALID_PROC_DIR(diag);
    }
    if (currentToken.lexeme != firstIdToken.lexeme) {
        auto diag = reportExpectedDifferentIdentifierInProcDir(currentToken, firstIdToken);
        return INVALID_PROC_DIR(diag);
    }
    secondIdToken = currentToken;
    consume(TokenType::Identifier);
    if (!match("ENDP")) {
        LOG_DETAILED_ERROR("shouldn't happen");
        return INVALID_PROC_DIR(std::nullopt);
    }
    endpDirToken = currentToken;
    consume("ENDP");
    return std::make_shared<ProcDir>(firstIdToken, directiveToken, fields, secondIdToken, endpDirToken);
}

std::shared_ptr<EquDir> Parser::parseEquDir()
{
    if (!match(TokenType::Identifier)) {
        auto diag = reportExpectedIdentifierInEquDir(currentToken);
        return INVALID_EQU_DIR(diag);
    }
    Token idToken = currentToken;
    consume(TokenType::Identifier);
    if (auto symbolPtr = parseSess->symbolTable->findSymbol(idToken)) {
        auto diag = reportSymbolRedefinition(idToken, symbolPtr->token);
        return INVALID_EQU_DIR(diag);
    }

    if (!match("EQU")) {
        LOG_DETAILED_ERROR("shouldn't happen");
        return INVALID_EQU_DIR(std::nullopt);
    }
    Token directiveToken = currentToken;
    consume(TokenType::Directive);

    // TODO: can also be a string in <> (or without <>?)
    ExpressionPtr expr = parseExpression();
    if (INVALID(expr)) {
        return INVALID_EQU_DIR(expr->diagnostic);
    }

    auto equDir = std::make_shared<EquDir>(idToken, directiveToken, expr);
    parseSess->symbolTable->addSymbol(std::make_shared<EquVariableSymbol>(idToken, equDir));

    return equDir;
}

std::shared_ptr<EqualDir> Parser::parseEqualDir()
{
    if (!match(TokenType::Identifier)) {
        auto diag = reportExpectedIdentifierInEqualDir(currentToken);
        return INVALID_EQUAL_DIR(diag);
    }
    Token idToken = currentToken;
    consume(TokenType::Identifier);
    // Redefinition is allowed for `=`
    if (auto symbolPtr = parseSess->symbolTable->findSymbol(idToken)) {
        if (!std::dynamic_pointer_cast<EqualVariableSymbol>(symbolPtr)) {
            auto diag = reportSymbolRedefinition(idToken, symbolPtr->token);
            return INVALID_EQUAL_DIR(diag);
        }
    }

    if (!match("=")) {
        LOG_DETAILED_ERROR("shouldn't happen");
        return INVALID_EQUAL_DIR(std::nullopt);
    }
    Token directiveToken = currentToken;
    consume(TokenType::Directive);

    ExpressionPtr expr = parseExpression();
    if (INVALID(expr)) {
        return INVALID_EQUAL_DIR(expr->diagnostic);
    }

    auto equalDir = std::make_shared<EqualDir>(idToken, directiveToken, expr);
    parseSess->symbolTable->addSymbol(std::make_shared<EqualVariableSymbol>(idToken, equalDir));

    return equalDir;
}

std::shared_ptr<EndDir> Parser::parseEndDir()
{
    if (!match("END")) {
        LOG_DETAILED_ERROR("shouldn't happen");
        return INVALID_END_DIR(std::nullopt);
    }
    Token directiveToken = currentToken;
    consume(TokenType::Directive);

    if (match(TokenType::EndOfLine) || match(TokenType::EndOfFile)) {
        return std::make_shared<EndDir>(directiveToken, std::nullopt);
    }

    ExpressionPtr expr = parseExpression();
    if (INVALID(expr)) {
        return INVALID_END_DIR(expr->diagnostic);
    }

    return std::make_shared<EndDir>(directiveToken, expr);
}

std::shared_ptr<Instruction> Parser::parseInstruction()
{
    std::optional<Token> label;
    std::optional<Token> menmonicToken;
    std::vector<ExpressionPtr> operands;
    if (lookaheadMatch(1, ":")) {
        if (!match(TokenType::Identifier)) {
            auto diag = reportExpectedIdentifierInLabel(currentToken);
            return INVALID_INSTRUCTION(diag);
        }
        Token labelToken = currentToken;
        consume(TokenType::Identifier);
        if (auto symbolPtr = parseSess->symbolTable->findSymbol(labelToken)) {
            auto diag = reportSymbolRedefinition(labelToken, symbolPtr->token);
            return INVALID_INSTRUCTION(diag);
        }
        parseSess->symbolTable->addSymbol(std::make_shared<LabelSymbol>(labelToken));
        consume(":");
        label = labelToken;
    }
    if (match(TokenType::EndOfLine) || match(TokenType::EndOfFile)) {
        return std::make_shared<Instruction>(label, std::nullopt, operands);
    }

    if (!match(TokenType::Instruction)) {
        auto diag = reportExpectedInstruction(currentToken);
        return INVALID_INSTRUCTION(diag);
    }
    menmonicToken = currentToken;
    consume(TokenType::Instruction);

    if (match(TokenType::EndOfLine) || match(TokenType::EndOfFile)) {
        // 0 arguments
        return std::make_shared<Instruction>(label, menmonicToken, operands);
    }
    ExpressionPtr expr = parseExpression();
    if (INVALID(expr)) {
        return INVALID_INSTRUCTION(expr->diagnostic);
    }
    operands.push_back(expr);
    while (match(",")) {
        consume(",");
        expr = parseExpression();
        if (INVALID(expr)) {
            return INVALID_INSTRUCTION(expr->diagnostic);
        }
        operands.push_back(expr);
    }
    if (!match(TokenType::EndOfLine) && !match(TokenType::EndOfFile)) {
        auto diag = reportExpectedCommaOrEndOfLine(currentToken);
        return INVALID_INSTRUCTION(diag);
    }
    return std::make_shared<Instruction>(label, menmonicToken, operands);
}

std::shared_ptr<DataItem> Parser::parseDataItem(const std::optional<Token> &idToken, const std::optional<Token> &strucNameToken)
{
    if (!match(TokenType::Identifier) && !match(dataDirectives)) {
        auto diag = reportExpectedVariableNameOrDataDirective(currentToken);
        return INVALID_DATA_ITEM(diag);
    }

    // TODO: determine whether is's a struct or record
    Token dataTypeToken = currentToken;
    advance();
    if (idToken && strucNameToken) {
        std::string fieldName = idToken.value().lexeme;
        std::shared_ptr<Symbol> symbol = parseSess->symbolTable->findSymbol(strucNameToken.value());
        auto structSymbol = std::dynamic_pointer_cast<StructSymbol>(symbol);
        structSymbol->namedFields[fieldName] = std::make_shared<DataVariableSymbol>(idToken.value(), dataTypeToken);
    } else if (idToken && !strucNameToken) {
        parseSess->symbolTable->addSymbol(std::make_shared<DataVariableSymbol>(idToken.value(), dataTypeToken));
    }
    std::shared_ptr<InitializerList> initValue = parseInitValues();
    if (INVALID(initValue)) {
        return INVALID_DATA_ITEM(initValue->diagnostic);
    }
    return std::make_shared<DataItem>(dataTypeToken, initValue);
}

std::shared_ptr<InitializerList> Parser::parseInitValues()
{
    dataInitializerDelimitersStack = {};
    std::shared_ptr<InitializerList> initValue = parseInitializerList();
    if (INVALID(initValue)) {
        return initValue;
    }
    if (!match(TokenType::EndOfLine) && !match(TokenType::EndOfFile)) {
        auto diag = reportExpectedCommaOrEndOfLine(currentToken);
        return INVALID_INITIALIZER_LIST(diag);
    }
    return initValue;
}

std::shared_ptr<InitValue> Parser::parseSingleInitValue()
{
    if (match("<")) {
        Token leftBracket = currentToken;
        dataInitializerDelimitersStack.push(leftBracket);
        advance();
        std::shared_ptr<InitializerList> fields = std::make_shared<InitializerList>(std::vector<std::shared_ptr<InitValue>>());
        if (match(">")) {
            Token rightBracket = currentToken;
            advance();
            dataInitializerDelimitersStack.pop();
            return std::make_shared<StructOrRecordInitValue>(leftBracket, rightBracket, fields);
        }
        fields = parseInitializerList();
        if (INVALID(fields)) {
            return INVALID_INIT_VALUE(fields->diagnostic);
        }
        std::optional<Token> rightBracket = consume(">");
        if (!rightBracket) {
            auto diag = reportUnclosedDelimiterInDataInitializer(currentToken);
            return INVALID_INIT_VALUE(diag);
        }
        dataInitializerDelimitersStack.pop();
        return std::make_shared<StructOrRecordInitValue>(leftBracket, rightBracket.value(), fields);
    } else if (match("?")) {
        Token token = currentToken;
        advance();
        return std::make_shared<QuestionMarkInitValue>(token);
    } else {
        ExpressionPtr expr = parseExpression();
        if (INVALID(expr)) {
            return INVALID_INIT_VALUE(expr->diagnostic);
        }
        if (match("DUP")) {
            Token op = currentToken;
            advance();
            std::optional<Token> leftBracket = consume("(");
            if (!leftBracket) {
                auto diag = reportExpectedOpenBracket(currentToken);
                return INVALID_INIT_VALUE(diag);
            }
            dataInitializerDelimitersStack.push(leftBracket.value());
            std::shared_ptr<InitializerList> operands = parseInitializerList();
            if (INVALID(operands)) {
                return INVALID_INIT_VALUE(operands->diagnostic);
            }
            std::optional<Token> rightBracket = consume(")");
            if (!rightBracket) {
                auto diag = reportUnclosedDelimiterInDataInitializer(currentToken);
                return INVALID_INIT_VALUE(diag);
            }
            dataInitializerDelimitersStack.pop();
            return std::make_shared<DupOperator>(expr, op, leftBracket.value(), operands, rightBracket.value());
        } else {
            // <var var> - can't be
            if (!dataInitializerDelimitersStack.empty() && !match(TokenType::CloseAngleBracket) && !match(TokenType::CloseBracket) &&
                !match(TokenType::Comma)) {
                if (match(TokenType::EndOfLine) || match(TokenType::EndOfFile)) {
                    auto diag = reportUnclosedDelimiterInDataInitializer(currentToken);
                    return INVALID_INIT_VALUE(diag);
                }
                auto diag = reportExpectedCommaOrClosingDelimiter(currentToken);
                return INVALID_INIT_VALUE(diag);
            }
        }
        return std::make_shared<ExpressionInitValue>(expr);
    }
}

std::shared_ptr<InitializerList> Parser::parseInitializerList()
{
    std::vector<std::shared_ptr<InitValue>> fields;
    std::shared_ptr<InitValue> initValue = parseSingleInitValue();
    if (INVALID(initValue)) {
        return INVALID_INITIALIZER_LIST(initValue->diagnostic);
    }
    fields.push_back(initValue);
    while (match(",")) {
        advance();
        initValue = parseSingleInitValue();
        if (INVALID(initValue)) {
            return INVALID_INITIALIZER_LIST(initValue->diagnostic);
        }
        fields.push_back(initValue);
    }

    return std::make_shared<InitializerList>(fields);
}

ExpressionPtr Parser::parseExpression()
{
    // need to initialize to {} before every parseExpression()
    expressionDelimitersStack = {};
    return parseExpressionHelper();
}

ExpressionPtr Parser::parseExpressionHelper()
{
    ExpressionPtr term1 = parseMultiplicativeExpression();
    if (INVALID(term1)) {
        return term1;
    }
    while (match("+") || match("-")) {
        Token op = currentToken;
        advance();
        ExpressionPtr term2 = parseMultiplicativeExpression();
        if (INVALID(term2)) {
            return term2;
        }
        term1 = std::make_shared<BinaryOperator>(op, term1, term2);
    }
    return term1;
}

ExpressionPtr Parser::parseMultiplicativeExpression()
{
    ExpressionPtr term1 = parseUnaryExpression();
    if (INVALID(term1)) {
        return term1;
    }
    while (match("*") || match("/") || match("MOD") || match("SHL") || match("SHR")) {
        Token op = currentToken;
        advance();
        ExpressionPtr term2 = parseUnaryExpression();
        if (INVALID(term2)) {
            return term2;
        }
        term1 = std::make_shared<BinaryOperator>(op, term1, term2);
    }
    return term1;
}

ExpressionPtr Parser::parseUnaryExpression()
{
    std::vector<Token> operators;
    while (match("+") || match("-") || match("OFFSET") || match("TYPE")) {
        Token op = currentToken;
        operators.push_back(op);
        advance();
    }
    ExpressionPtr term = parsePtrExpression();
    if (INVALID(term)) {
        return term;
    }
    for (const Token &op : std::ranges::reverse_view(operators)) {
        term = std::make_shared<UnaryOperator>(op, term);
    }
    return term;
}

ExpressionPtr Parser::parsePtrExpression()
{
    ExpressionPtr term1 = parseMemberAccessAndIndexingExpression();
    if (INVALID(term1)) {
        return term1;
    }
    while (match("PTR")) {
        Token op = currentToken;
        advance();
        ExpressionPtr term2 = parseMemberAccessAndIndexingExpression();
        if (INVALID(term2)) {
            return term2;
        }
        term1 = std::make_shared<BinaryOperator>(op, term1, term2);
    }
    return term1;
}

ExpressionPtr Parser::parseMemberAccessAndIndexingExpression()
{
    ExpressionPtr term1 = parseHighPrecedenceUnaryExpression();
    if (INVALID(term1)) {
        return term1;
    }
    while (match(TokenType::OpenSquareBracket) || match(TokenType::OpenBracket) || match(".")) {
        if (match(TokenType::OpenSquareBracket)) {
            Token leftBracket = currentToken;
            expressionDelimitersStack.push(leftBracket);
            advance();
            ExpressionPtr expr = parseExpressionHelper();
            if (INVALID(expr)) {
                return expr;
            }
            std::optional<Token> rightBracket = consume(TokenType::CloseSquareBracket);
            if (!rightBracket) {
                std::shared_ptr<Diagnostic> diag = reportUnclosedDelimiterError(currentToken);
                return INVALID_EXPRESSION(diag);
            }
            expressionDelimitersStack.pop();
            ExpressionPtr term2 = std::make_shared<SquareBrackets>(leftBracket, rightBracket.value(), expr);
            term1 = std::make_shared<ImplicitPlusOperator>(term1, term2);
        } else if (match(TokenType::OpenBracket)) {
            Token leftBracket = currentToken;
            expressionDelimitersStack.push(leftBracket);
            advance();
            ExpressionPtr expr = parseExpressionHelper();
            if (INVALID(expr)) {
                return expr;
            }
            std::optional<Token> rightBracket = consume(TokenType::CloseBracket);
            if (!rightBracket) {
                std::shared_ptr<Diagnostic> diag = reportUnclosedDelimiterError(currentToken);
                return INVALID_EXPRESSION(diag);
            }
            expressionDelimitersStack.pop();
            ExpressionPtr term2 = std::make_shared<Brackets>(leftBracket, rightBracket.value(), expr);
            term1 = std::make_shared<ImplicitPlusOperator>(term1, term2);
        } else if (match(".")) {
            Token dot = currentToken;
            advance();
            if (currentToken.type != TokenType::Identifier) {
                auto diag = reportExpectedIdentifierInExpression(currentToken);
                return INVALID_EXPRESSION(diag);
            }
            auto term2 = std::make_shared<Leaf>(currentToken);
            advance();
            term1 = std::make_shared<BinaryOperator>(dot, term1, term2);
        }
    }
    return term1;
}

ExpressionPtr Parser::parseHighPrecedenceUnaryExpression()
{
    std::vector<Token> operators;
    while (match("LENGTH") || match("LENGTHOF") || match("SIZE") || match("SIZEOF") || match("WIDTH") || match("MASK")) {
        Token op = currentToken;
        operators.push_back(op);
        advance();
    }

    ExpressionPtr term = parsePrimaryExpression();
    if (INVALID(term)) {
        return term;
    }
    for (const Token &op : std::ranges::reverse_view(operators)) {
        term = std::make_shared<UnaryOperator>(op, term);
    }
    return term;
}

ExpressionPtr Parser::parsePrimaryExpression()
{
    if (match(TokenType::OpenBracket)) {
        Token leftBracket = currentToken;
        expressionDelimitersStack.push(leftBracket);
        advance();
        ExpressionPtr expr = parseExpressionHelper();
        if (INVALID(expr)) {
            return expr;
        }
        std::optional<Token> rightBracket = consume(TokenType::CloseBracket);
        if (!rightBracket) {
            auto diag = reportUnclosedDelimiterError(currentToken);
            return INVALID_EXPRESSION(diag);
        }
        expressionDelimitersStack.pop();
        return std::make_shared<Brackets>(leftBracket, rightBracket.value(), expr);

    } else if (match(TokenType::OpenSquareBracket)) {
        Token leftBracket = currentToken;
        expressionDelimitersStack.push(leftBracket);
        advance();
        ExpressionPtr expr = parseExpressionHelper();
        if (INVALID(expr)) {
            return expr;
        }
        std::optional<Token> rightBracket = consume(TokenType::CloseSquareBracket);
        if (!rightBracket) {
            auto diag = reportUnclosedDelimiterError(currentToken);
            return INVALID_EXPRESSION(diag);
        }
        expressionDelimitersStack.pop();
        return std::make_shared<SquareBrackets>(leftBracket, rightBracket.value(), expr);
    } else if (match(TokenType::Identifier) || match(TokenType::Number) || match(TokenType::StringLiteral) || match(TokenType::Register) ||
               match(TokenType::Type) || match(TokenType::Dollar)) {
        Token token = currentToken;
        advance();
        std::string curentTokenLexemeUpper = stringToUpper(currentToken.lexeme);
        // (var var) - can't be
        // after leaf when there'are unclosed parenthesis `()` or `[]` must be operator (binary operator)
        // or closing `)` or `]`
        // or there might be `(` or `[` - implicit plus for index operator
        if (!expressionDelimitersStack.empty() && currentToken.type != TokenType::CloseSquareBracket &&
            currentToken.type != TokenType::CloseBracket && currentToken.type != TokenType::OpenSquareBracket &&
            currentToken.type != TokenType::OpenBracket && curentTokenLexemeUpper != "+" && curentTokenLexemeUpper != "-" &&
            curentTokenLexemeUpper != "*" && curentTokenLexemeUpper != "/" && curentTokenLexemeUpper != "PTR" && curentTokenLexemeUpper != "." &&
            curentTokenLexemeUpper != "MOD" && curentTokenLexemeUpper != "SHL" && curentTokenLexemeUpper != "SHR") {

            // try to distinct between `(var var` and `(1 + 2` or `(1 + 2,
            // when after var there aren't any vars and only possible closing things and then endofline -
            if (currentToken.type == TokenType::EndOfLine || currentToken.type == TokenType::EndOfFile || currentToken.type == TokenType::Comma) {
                auto diag = reportUnclosedDelimiterError(currentToken);
                return INVALID_EXPRESSION(diag);
            }
            auto diag = reportExpectedOperatorOrClosingDelimiter(currentToken);
            return INVALID_EXPRESSION(diag);
        }
        // var var - can't be - handled in the upper parsing (only var is parsed as expression)
        return std::make_shared<Leaf>(token);
    } else {
        auto diag = reportExpectedExpression(currentToken);
        return INVALID_EXPRESSION(diag);
    }
}

File parser.h:

#pragma once

#include <stack>
#include <unordered_set>

#include "symbol_table.h"
#include "diag_ctxt.h"
#include "preprocessor.h"
#include "session.h"
#include "ast.h"

enum class TokenType : uint8_t;

class Parser {
public:
    Parser(const std::shared_ptr<ParseSession> &parseSession, const std::vector<Token> &tokens);
    ASTPtr parse();

private:
    std::shared_ptr<ParseSession> parseSess;
    const std::vector<Token> &tokens;
    size_t currentIndex = 0;
    Token currentToken;

    std::optional<std::string> currentSegment;

    std::stack<Token> expressionDelimitersStack;
    std::stack<Token> dataInitializerDelimitersStack;

    void advance();
    void synchronize();
    bool match(TokenType type) const;
    bool match(const std::string &value) const;
    bool match(TokenType type, const std::string &value) const;
    bool match(const std::unordered_set<std::string> &values) const;
    std::optional<Token> consume(TokenType type);
    std::optional<Token> consume(const std::string &value);
    bool lookaheadMatch(size_t n, const std::string &value) const;
    bool lookaheadMatch(size_t n, const std::unordered_set<std::string> &values) const;
    bool lookaheadMatch(size_t n, TokenType type) const;
    bool lookaheadNextLineMatch(const std::string &value) const;

    [[nodiscard]] std::shared_ptr<Statement> parseStatement();

    [[nodiscard]] std::shared_ptr<SegDir> parseSegDir();
    [[nodiscard]] std::shared_ptr<DataDir> parseDataDir(const std::optional<Token> &strucNameToken = std::nullopt);
    [[nodiscard]] std::shared_ptr<StructDir> parseStructDir();
    [[nodiscard]] std::shared_ptr<ProcDir> parseProcDir();
    [[nodiscard]] std::shared_ptr<RecordDir> parseRecordDir();
    [[nodiscard]] std::shared_ptr<RecordField> parseRecordField();
    [[nodiscard]] std::shared_ptr<EquDir> parseEquDir();
    [[nodiscard]] std::shared_ptr<EqualDir> parseEqualDir();
    [[nodiscard]] std::shared_ptr<EndDir> parseEndDir();

    [[nodiscard]] std::shared_ptr<Instruction> parseInstruction();

    [[nodiscard]] std::shared_ptr<DataItem> parseDataItem(const std::optional<Token> &idToken, const std::optional<Token> &strucNameToken);
    [[nodiscard]] std::shared_ptr<InitializerList> parseInitValues();
    [[nodiscard]] std::shared_ptr<InitValue> parseSingleInitValue();
    [[nodiscard]] std::shared_ptr<InitializerList> parseInitializerList();

    [[nodiscard]] ExpressionPtr parseExpression();
    [[nodiscard]] ExpressionPtr parseExpressionHelper();
    [[nodiscard]] ExpressionPtr parseMultiplicativeExpression();
    [[nodiscard]] ExpressionPtr parseUnaryExpression();
    [[nodiscard]] ExpressionPtr parsePtrExpression();
    [[nodiscard]] ExpressionPtr parseMemberAccessAndIndexingExpression();
    [[nodiscard]] ExpressionPtr parseHighPrecedenceUnaryExpression();
    [[nodiscard]] ExpressionPtr parsePrimaryExpression();

    // General
    [[nodiscard]] std::shared_ptr<Diagnostic> reportSymbolRedefinition(const Token &token, const Token &firstDefinedToken);

    // Program
    [[nodiscard]] std::shared_ptr<Diagnostic> reportExpectedEndOfLine(const Token &token);
    [[nodiscard]] std::shared_ptr<Diagnostic> reportExpectedEndDir(const Token &token);

    // Statement
    [[nodiscard]] std::shared_ptr<Diagnostic> reportMustBeInSegmentBlock(const Token &firstToken, const Token &lastToken);

    // SegDir

    // DataDir
    [[nodiscard]] std::shared_ptr<Diagnostic> reportExpectedIdentifierInDataDir(const Token &token);

    // StructDir
    [[nodiscard]] std::shared_ptr<Diagnostic> reportExpectedIdentifierBeforeStruc(const Token &token);
    [[nodiscard]] std::shared_ptr<Diagnostic> reportExpectedIdentifierInStrucDir(const Token &token);
    [[nodiscard]] std::shared_ptr<Diagnostic> reportExpectedDifferentIdentifierInStructDir(const Token &found, const Token &expected);
    [[nodiscard]] std::shared_ptr<Diagnostic> reportExpectedEnds(const Token &token);
    [[nodiscard]] std::shared_ptr<Diagnostic> reportMissingIdentifierBeforeEnds(const Token &token);

    // ProcDir
    [[nodiscard]] std::shared_ptr<Diagnostic> reportExpectedIdentifierBeforeProc(const Token &token);
    [[nodiscard]] std::shared_ptr<Diagnostic> reportExpectedIdentifierInProcDir(const Token &token);
    [[nodiscard]] std::shared_ptr<Diagnostic> reportExpectedDifferentIdentifierInProcDir(const Token &found, const Token &expected);
    [[nodiscard]] std::shared_ptr<Diagnostic> reportExpectedEndp(const Token &token);
    [[nodiscard]] std::shared_ptr<Diagnostic> reportMissingIdentifierBeforeEndp(const Token &token);

    // RecordDir
    [[nodiscard]] std::shared_ptr<Diagnostic> reportExpectedIdentifierInRecordDir(const Token &token);
    [[nodiscard]] std::shared_ptr<Diagnostic> reportExpectedColonInRecordField(const Token &token);
    [[nodiscard]] std::shared_ptr<Diagnostic> reportExpectedIdentifierBeforeRecord(const Token &token);

    // EquDir
    [[nodiscard]] std::shared_ptr<Diagnostic> reportExpectedIdentifierInEquDir(const Token &token);
    [[nodiscard]] std::shared_ptr<Diagnostic> reportExpectedIdentifierBeforeEqu(const Token &token);

    // EqualDir
    [[nodiscard]] std::shared_ptr<Diagnostic> reportExpectedIdentifierInEqualDir(const Token &token);
    [[nodiscard]] std::shared_ptr<Diagnostic> reportExpectedIdentifierBeforeEqual(const Token &token);

    // Instruction
    [[nodiscard]] std::shared_ptr<Diagnostic> reportExpectedInstruction(const Token &token);
    [[nodiscard]] std::shared_ptr<Diagnostic> reportExpectedCommaOrEndOfLine(const Token &token);
    [[nodiscard]] std::shared_ptr<Diagnostic> reportExpectedIdentifierInLabel(const Token &token);

    // DataItem
    [[nodiscard]] std::shared_ptr<Diagnostic> reportExpectedVariableNameOrDataDirective(const Token &token);

    // InitValue
    [[nodiscard]] std::shared_ptr<Diagnostic> reportUnclosedDelimiterInDataInitializer(const Token &token);
    [[nodiscard]] std::shared_ptr<Diagnostic> reportExpectedCommaOrClosingDelimiter(const Token &token);
    [[nodiscard]] std::shared_ptr<Diagnostic> reportExpectedOpenBracket(const Token &token);

    // Expression
    [[nodiscard]] std::shared_ptr<Diagnostic> reportUnclosedDelimiterError(const Token &closingDelimiter);
    [[nodiscard]] std::shared_ptr<Diagnostic> reportExpectedExpression(const Token &token);
    [[nodiscard]] std::shared_ptr<Diagnostic> reportExpectedOperatorOrClosingDelimiter(const Token &token);
    [[nodiscard]] std::shared_ptr<Diagnostic> reportExpectedIdentifierInExpression(const Token &token);
};
File parser_errors_reporting.cpp:

#include "parser.h"
#include "log.h"
#include "token.h"

// General
std::shared_ptr<Diagnostic> Parser::reportSymbolRedefinition(const Token &token, const Token &firstDefinedToken)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::SYMBOL_REDEFINITION, token.lexeme);
    diag.addPrimaryLabel(token.span, "");
    diag.addSecondaryLabel(firstDefinedToken.span, "first defined here");
    parseSess->dcx->addDiagnostic(diag);

    return parseSess->dcx->getLastDiagnostic();
}

// Program
std::shared_ptr<Diagnostic> Parser::reportExpectedEndOfLine(const Token &token)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::EXPECTED_END_OF_LINE, token.lexeme);
    diag.addPrimaryLabel(token.span, "");
    parseSess->dcx->addDiagnostic(diag);

    return parseSess->dcx->getLastDiagnostic();
}

std::shared_ptr<Diagnostic> Parser::reportExpectedEndDir(const Token &token)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::EXPECTED_END_DIR);
    diag.addPrimaryLabel(token.span, "");
    parseSess->dcx->addDiagnostic(diag);

    return parseSess->dcx->getLastDiagnostic();
}

// Statement
std::shared_ptr<Diagnostic> Parser::reportMustBeInSegmentBlock(const Token &firstToken, const Token &lastToken)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::MUST_BE_IN_SEGMENT_BLOCK);
    Span span = Span::merge(firstToken.span, lastToken.span);
    diag.addPrimaryLabel(span, "");
    parseSess->dcx->addDiagnostic(diag);

    return parseSess->dcx->getLastDiagnostic();
}

// SegDir

// DataDir
std::shared_ptr<Diagnostic> Parser::reportExpectedIdentifierInDataDir(const Token &token)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::EXPECTED_IDENTIFIER, token.lexeme);

    if (isReservedWord(token)) {
        diag.addPrimaryLabel(token.span, fmt::format("`{}` is a reserved word", token.lexeme));

    } else {
        diag.addPrimaryLabel(token.span, "");
    }

    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

// StructDir
std::shared_ptr<Diagnostic> Parser::reportExpectedIdentifierBeforeStruc(const Token &token)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::EXPECTED_IDENTIFIER_BEFORE_STRUC);
    diag.addPrimaryLabel(token.span, "");
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

std::shared_ptr<Diagnostic> Parser::reportExpectedIdentifierInStrucDir(const Token &token)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::EXPECTED_IDENTIFIER, token.lexeme);

    if (isReservedWord(token)) {
        diag.addPrimaryLabel(token.span, fmt::format("`{}` is a reserved word", token.lexeme));

    } else {
        diag.addPrimaryLabel(token.span, "");
    }

    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

std::shared_ptr<Diagnostic> Parser::reportExpectedDifferentIdentifierInStructDir(const Token &found, const Token &expected)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::EXPECTED_DIFFERENT_IDENTIFIER_STRUCT_DIR);
    diag.addPrimaryLabel(found.span, fmt::format("expected `{}`", expected.lexeme));
    parseSess->dcx->addDiagnostic(diag);

    return parseSess->dcx->getLastDiagnostic();
}

std::shared_ptr<Diagnostic> Parser::reportExpectedEnds(const Token &token)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::EXPECTED_ENDS);
    diag.addPrimaryLabel(token.span, "");
    parseSess->dcx->addDiagnostic(diag);

    return parseSess->dcx->getLastDiagnostic();
}

std::shared_ptr<Diagnostic> Parser::reportMissingIdentifierBeforeEnds(const Token &token)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::MISSING_IDENTIFIER_BEFORE_ENDS);
    diag.addPrimaryLabel(token.span, "");
    parseSess->dcx->addDiagnostic(diag);

    return parseSess->dcx->getLastDiagnostic();
}

// ProcDir
std::shared_ptr<Diagnostic> Parser::reportExpectedIdentifierBeforeProc(const Token &token)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::EXPECTED_IDENTIFIER_BEFORE_PROC);
    diag.addPrimaryLabel(token.span, "");
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

std::shared_ptr<Diagnostic> Parser::reportExpectedIdentifierInProcDir(const Token &token)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::EXPECTED_IDENTIFIER, token.lexeme);

    if (isReservedWord(token)) {
        diag.addPrimaryLabel(token.span, fmt::format("`{}` is a reserved word", token.lexeme));

    } else {
        diag.addPrimaryLabel(token.span, "");
    }

    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

std::shared_ptr<Diagnostic> Parser::reportExpectedDifferentIdentifierInProcDir(const Token &found, const Token &expected)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::EXPECTED_DIFFERENT_IDENTIFIER_PROC_DIR);
    diag.addPrimaryLabel(found.span, fmt::format("expected `{}`", expected.lexeme));
    parseSess->dcx->addDiagnostic(diag);

    return parseSess->dcx->getLastDiagnostic();
}

std::shared_ptr<Diagnostic> Parser::reportExpectedEndp(const Token &token)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::EXPECTED_ENDP);
    diag.addPrimaryLabel(token.span, "");
    parseSess->dcx->addDiagnostic(diag);

    return parseSess->dcx->getLastDiagnostic();
}

std::shared_ptr<Diagnostic> Parser::reportMissingIdentifierBeforeEndp(const Token &token)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::MISSING_IDENTIFIER_BEFORE_ENDP);
    diag.addPrimaryLabel(token.span, "");
    parseSess->dcx->addDiagnostic(diag);

    return parseSess->dcx->getLastDiagnostic();
}

// RecordDir
std::shared_ptr<Diagnostic> Parser::reportExpectedIdentifierInRecordDir(const Token &token)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::EXPECTED_IDENTIFIER, token.lexeme);

    if (isReservedWord(token)) {
        diag.addPrimaryLabel(token.span, fmt::format("`{}` is a reserved word", token.lexeme));

    } else {
        diag.addPrimaryLabel(token.span, "");
    }

    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

std::shared_ptr<Diagnostic> Parser::reportExpectedColonInRecordField(const Token &token)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::EXPECTED_COLON_IN_RECORD_DIR);
    diag.addPrimaryLabel(token.span, "");
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

std::shared_ptr<Diagnostic> Parser::reportExpectedIdentifierBeforeRecord(const Token &token)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::EXPECTED_IDENTIFIER_BEFORE_RECORD);
    diag.addPrimaryLabel(token.span, "");
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

// EqualDir
std::shared_ptr<Diagnostic> Parser::reportExpectedIdentifierInEquDir(const Token &token)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::EXPECTED_IDENTIFIER, token.lexeme);

    if (isReservedWord(token)) {
        diag.addPrimaryLabel(token.span, fmt::format("`{}` is a reserved word", token.lexeme));

    } else {
        diag.addPrimaryLabel(token.span, "");
    }

    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

std::shared_ptr<Diagnostic> Parser::reportExpectedIdentifierBeforeEqu(const Token &token)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::EXPECTED_IDENTIFIER_BEFORE_EQU);
    diag.addPrimaryLabel(token.span, "");
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

// EqualDir
std::shared_ptr<Diagnostic> Parser::reportExpectedIdentifierInEqualDir(const Token &token)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::EXPECTED_IDENTIFIER, token.lexeme);

    if (isReservedWord(token)) {
        diag.addPrimaryLabel(token.span, fmt::format("`{}` is a reserved word", token.lexeme));

    } else {
        diag.addPrimaryLabel(token.span, "");
    }

    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

std::shared_ptr<Diagnostic> Parser::reportExpectedIdentifierBeforeEqual(const Token &token)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::EXPECTED_IDENTIFIER_BEFORE_EQUAL);
    diag.addPrimaryLabel(token.span, "");
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

// Instruction
std::shared_ptr<Diagnostic> Parser::reportExpectedInstruction(const Token &token)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::EXPECTED_INSTRUCTION);
    if (isReservedWord(token)) {
        diag.addPrimaryLabel(token.span, "this is a reserved word");
    } else if (token.type == TokenType::Identifier) {
        diag.addPrimaryLabel(token.span, "this instruction name is incorrect");
    } else {
        diag.addPrimaryLabel(token.span, "");
    }
    parseSess->dcx->addDiagnostic(diag);

    return parseSess->dcx->getLastDiagnostic();
}

std::shared_ptr<Diagnostic> Parser::reportExpectedCommaOrEndOfLine(const Token &token)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::EXPECTED_COMMA_OR_END_OF_LINE, token.lexeme);
    diag.addPrimaryLabel(token.span, "");
    parseSess->dcx->addDiagnostic(diag);

    return parseSess->dcx->getLastDiagnostic();
}

std::shared_ptr<Diagnostic> Parser::reportExpectedIdentifierInLabel(const Token &token)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::EXPECTED_IDENTIFIER, token.lexeme);

    if (isReservedWord(token)) {
        diag.addPrimaryLabel(token.span, fmt::format("`{}` is a reserved word", token.lexeme));

    } else {
        diag.addPrimaryLabel(token.span, "");
    }

    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

// DataItem
std::shared_ptr<Diagnostic> Parser::reportExpectedVariableNameOrDataDirective(const Token &token)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::EXPECTED_VARIABLE_NAME_OR_DATA_DIRECTIVE, token.lexeme);
    diag.addPrimaryLabel(token.span, "");
    parseSess->dcx->addDiagnostic(diag);

    return parseSess->dcx->getLastDiagnostic();
}

// InitValue
std::shared_ptr<Diagnostic> Parser::reportUnclosedDelimiterInDataInitializer(const Token &token)
{
    if (dataInitializerDelimitersStack.empty()) {
        LOG_DETAILED_ERROR("Empty demimiters stack!");
    } else {
        Diagnostic diag(Diagnostic::Level::Error, ErrorCode::UNCLOSED_DELIMITER, dataInitializerDelimitersStack.top().lexeme);
        diag.addPrimaryLabel(token.span, "");
        Token openingDelimiter = dataInitializerDelimitersStack.top();
        diag.addSecondaryLabel(openingDelimiter.span, "unclosed delimiter");
        parseSess->dcx->addDiagnostic(diag);
    }
    return parseSess->dcx->getLastDiagnostic();
}

std::shared_ptr<Diagnostic> Parser::reportExpectedCommaOrClosingDelimiter(const Token &token)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::EXPECTED_COMMA_OR_CLOSING_DELIMITER, token.lexeme);
    diag.addPrimaryLabel(token.span, "");
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

std::shared_ptr<Diagnostic> Parser::reportExpectedOpenBracket(const Token &token)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::EXPECTED_OPEN_BRACKET, token.lexeme);
    diag.addPrimaryLabel(token.span, "");
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

// Expression
std::shared_ptr<Diagnostic> Parser::reportUnclosedDelimiterError(const Token &closingDelimiter)
{
    if (expressionDelimitersStack.empty()) {
        LOG_DETAILED_ERROR("Empty demimiters stack!");
    } else {
        Diagnostic diag(Diagnostic::Level::Error, ErrorCode::UNCLOSED_DELIMITER, expressionDelimitersStack.top().lexeme);
        diag.addPrimaryLabel(closingDelimiter.span, "");
        Token openingDelimiter = expressionDelimitersStack.top();
        diag.addSecondaryLabel(openingDelimiter.span, "unclosed delimiter");
        parseSess->dcx->addDiagnostic(diag);
    }
    return parseSess->dcx->getLastDiagnostic();
}

std::shared_ptr<Diagnostic> Parser::reportExpectedExpression(const Token &token)
{
    if ((token.type == TokenType::CloseSquareBracket || token.type == TokenType::CloseBracket) && expressionDelimitersStack.empty()) {
        Diagnostic diag(Diagnostic::Level::Error, ErrorCode::UNEXPECTED_CLOSING_DELIMITER, token.lexeme);
        diag.addPrimaryLabel(token.span, "");
        parseSess->dcx->addDiagnostic(diag);
    } else {
        std::string lexeme;
        if (token.type == TokenType::EndOfLine) {
            lexeme = "\\n";
        } else if (token.type == TokenType::EndOfFile) {
            lexeme = "End Of File";
        } else {
            lexeme = token.lexeme;
        }
        Diagnostic diag(Diagnostic::Level::Error, ErrorCode::EXPECTED_EXPRESSION, lexeme);
        diag.addPrimaryLabel(token.span, "");

        // 10 * MOD 3 - causes unexpected MOD
        // PTR [eax] - causes unexpected PTR
        // add note message, saying that MOD, SHL, SHR, PTR take 2 arguments
        // other binary operators are obvious enough
        std::string lexemeUpper = stringToUpper(token.lexeme);
        if (lexemeUpper == "MOD" || lexemeUpper == "SHL" || lexemeUpper == "SHR" || lexemeUpper == "PTR") {
            diag.addNoteMessage(fmt::format("{} operator takes 2 arguments", lexemeUpper));
        }
        parseSess->dcx->addDiagnostic(diag);
    }
    return parseSess->dcx->getLastDiagnostic();
}

std::shared_ptr<Diagnostic> Parser::reportExpectedOperatorOrClosingDelimiter(const Token &token)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::EXCPECTED_OPERATOR_OR_CLOSING_DELIMITER, token.lexeme);
    diag.addPrimaryLabel(token.span, "");
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

std::shared_ptr<Diagnostic> Parser::reportExpectedIdentifierInExpression(const Token &token)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::EXPECTED_IDENTIFIER, token.lexeme);
    diag.addPrimaryLabel(token.span, "this needs to be a field name");
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

File preprocessor.cpp:

#include "preprocessor.h"
#include "token.h"
#include <sstream>
#include <algorithm>
#include <stdexcept>

Preprocessor::Preprocessor(const std::shared_ptr<ParseSession> &parseSess, const std::vector<Token> &tokens)
    : parseSess(parseSess), tokens(tokens)
{
}

std::vector<Token> Preprocessor::preprocess() const
{
    // TODO: implement preprocessing
    return tokens;
}

File preprocessor.h:

#pragma once

#include "diag_ctxt.h"
#include "token.h"
#include "session.h"
#include <string>
#include <vector>
#include <stack>
#include <unordered_map>
#include <memory>

class Preprocessor {
public:
    Preprocessor(const std::shared_ptr<ParseSession> &parseSess, const std::vector<Token> &tokens);
    std::vector<Token> preprocess() const;

private:
    std::shared_ptr<ParseSession> parseSess;
    const std::vector<Token> &tokens;
};

File semantic_analyzer.cpp:

// File: semantic_analyzer.cpp
#include "semantic_analyzer.h"
#include "log.h"
#include <set>
#include <unordered_set>
#include <cstdint>

std::map<std::string, int> SemanticAnalyzer::registerSizes = {{"AL", 1}, {"AX", 2},  {"EAX", 4}, {"BL", 1},  {"BX", 2},  {"EBX", 4}, {"CL", 1},
                                                              {"CX", 2}, {"ECX", 4}, {"DL", 1},  {"DX", 2},  {"EDX", 4}, {"SI", 2},  {"ESI", 4},
                                                              {"DI", 2}, {"EDI", 4}, {"BP", 2},  {"EBP", 4}, {"SP", 2},  {"ESP", 4}};

std::map<int, std::string> SemanticAnalyzer::sizeValueToStr = {{1, "BYTE"}, {2, "WORD"}, {4, "DWORD"}, {8, "QWORD"}};

std::map<std::string, int> SemanticAnalyzer::sizeStrToValue = {{"BYTE", 1}, {"WORD", 2}, {"DWORD", 4}, {"QWORD", 8}};

std::map<std::string, std::string> SemanticAnalyzer::dataDirectiveToSizeStr = {{"DB", "BYTE"}, {"DW", "WORD"}, {"DD", "DWORD"}, {"DQ", "QWORD"}};

std::unordered_set<std::string> SemanticAnalyzer::builtinTypes = {"BYTE", "WORD", "DWORD", "QWORD"};

std::unordered_set<std::string> SemanticAnalyzer::dataDirectives = {"DB", "DW", "DD", "DQ"};

SemanticAnalyzer::SemanticAnalyzer(std::shared_ptr<ParseSession> parseSession, ASTPtr ast) : parseSess(std::move(parseSession)), ast(std::move(ast))
{
}

void SemanticAnalyzer::analyze() { visit(ast); }

void SemanticAnalyzer::visit(const ASTPtr &node)
{
    if (auto program = std::dynamic_pointer_cast<Program>(node)) {
        for (const auto &statement : program->statements) {
            if (INVALID(statement)) {
                continue;
            }
            std::ignore = visitStatement(statement);
        }
        if (program->endDir) {
            std::ignore = visitDirective(program->endDir);
        }
    } else {
        LOG_DETAILED_ERROR("Top AST Node must be Program");
    }
}

bool SemanticAnalyzer::visitStatement(const std::shared_ptr<Statement> &statement)
{
    if (auto instruction = std::dynamic_pointer_cast<Instruction>(statement)) {
        return visitInstruction(instruction);
    } else if (auto directive = std::dynamic_pointer_cast<Directive>(statement)) {
        return visitDirective(directive);
    } else {
        LOG_DETAILED_ERROR("Unknown statement type.");
        return false;
    }
}

bool SemanticAnalyzer::visitInstruction(const std::shared_ptr<Instruction> &instruction)
{
    for (const auto &operand : instruction->operands) {
        bool success = visitExpression(operand, ExpressionContext(ExprCtxtFlags::AllowRegisters | ExprCtxtFlags::AllowForwardReferences));
        if (!success) {
            instruction->diagnostic = operand->diagnostic;
            return false;
        }
        if (operand->type == OperandType::UnfinishedMemoryOperand) {
            instruction->diagnostic = reportCantHaveRegistersInExpression(operand);
            return false;
        }
        if (operand->type == OperandType::Unspecified) {
            LOG_DETAILED_ERROR("Unspecified operand type, should've been catched earlier");
            return false;
        }
    }

    if (instruction->label) {
        std::shared_ptr<Symbol> symbol = parseSess->symbolTable->findSymbol(instruction->label.value());
        auto labelSymbol = std::dynamic_pointer_cast<LabelSymbol>(symbol);
        if (!labelSymbol) {
            LOG_DETAILED_ERROR("no label symbol in the symbol table, when should be");
            return false;
        }
        labelSymbol->value = -1; // TODO: calculate actual value
        labelSymbol->wasDefined = true;
    }

    if (!instruction->mnemonicToken) {
        // only label exist
        return true;
    }
    // TODO: finish all possible instructions (dont forget about unresolvedSymbols)
    Token mnemonicToken = instruction->mnemonicToken.value();
    std::string mnemonic = stringToUpper(mnemonicToken.lexeme);

    // TODO: delete if some instruction accepts 8 bytes operand
    for (const auto &operand : instruction->operands) {
        if (operand->size) {
            int opSize = operand->size.value().value;
            if (opSize != 1 && opSize != 2 && opSize != 4 && !operand->unresolvedSymbols) {
                instruction->diagnostic = reportInvalidOperandSize(operand, "{1, 2, 4}", opSize);
                return false;
            }
        }
    }

    if (mnemonic == "ADC" || mnemonic == "ADD" || mnemonic == "AND" || mnemonic == "CMP" || mnemonic == "MOV") {
        if (instruction->operands.size() != 2) {
            instruction->diagnostic = reportInvalidNumberOfOperands(instruction, 2);
            return false;
        }
        ExpressionPtr firstOp = instruction->operands[0];
        ExpressionPtr secondOp = instruction->operands[1];
        if (firstOp->type == OperandType::MemoryOperand && secondOp->type == OperandType::MemoryOperand) {
            instruction->diagnostic = reportCantHaveTwoMemoryOperands(instruction);
            return false;
        }
        if (firstOp->type == OperandType::ImmediateOperand) {
            instruction->diagnostic = reportDestinationOperandCantBeImmediate(instruction);
            return false;
        }

        // find out actual size of constantValue
        if (secondOp->constantValue) {
            int64_t value = secondOp->constantValue.value();
            if (value >= INT8_MIN && value <= static_cast<int64_t>(UINT8_MAX)) {
                secondOp->size = OperandSize("BYTE", 1);
            } else if (value >= INT16_MIN && value <= static_cast<int64_t>(UINT16_MAX)) {
                secondOp->size = OperandSize("WORD", 2);
            } else if (value >= INT32_MIN && value <= static_cast<int64_t>(UINT32_MAX)) {
                secondOp->size = OperandSize("DWORD", 4);
            } else {
                secondOp->size = OperandSize("DWORD", 8);
            }
        }

        // !firstOp->size && !secondOp->size - shouldn't happen, because then it's two memory operands
        if (firstOp->size && secondOp->size) {
            int firstOpSize = firstOp->size.value().value;
            int secondOpSize = secondOp->size.value().value;
            if (secondOp->constantValue && firstOpSize < secondOpSize && !(firstOp->unresolvedSymbols || secondOp->unresolvedSymbols)) {
                instruction->diagnostic = reportImmediateOperandTooBig(instruction, firstOpSize, secondOpSize);
                return false;
            }
            if (!secondOp->constantValue && firstOpSize != secondOpSize && !(firstOp->unresolvedSymbols || secondOp->unresolvedSymbols)) {
                instruction->diagnostic = reportOperandsHaveDifferentSize(instruction, firstOpSize, secondOpSize);
                return false;
            }
        }
    } else if (mnemonic == "CALL") {
        if (instruction->operands.size() != 1) {
            instruction->diagnostic = reportInvalidNumberOfOperands(instruction, 1);
            return false;
        }
        ExpressionPtr operand = instruction->operands[0];
        if (operand->type != OperandType::MemoryOperand && operand->type != OperandType::RegisterOperand) {
            instruction->diagnostic = reportExpressionMustBeMemoryOrRegisterOperand(operand);
            return false;
        }
        if (!operand->size) {
            instruction->diagnostic = reportExpressionMustHaveSize(operand);
            return false;
        }
        int operandSize = operand->size.value().value;
        if (operandSize != 4 && !operand->unresolvedSymbols) {
            instruction->diagnostic = reportInvalidOperandSize(operand, "4", operandSize);
            return false;
        }
    } else if (mnemonic == "CBW" || mnemonic == "CDQ" || mnemonic == "CWD") {
        if (instruction->operands.size() != 0) {
            instruction->diagnostic = reportInvalidNumberOfOperands(instruction, 0);
            return false;
        }
    } else if (mnemonic == "DEC" || mnemonic == "DIV" || mnemonic == "IDIV") {
        if (instruction->operands.size() != 1) {
            instruction->diagnostic = reportInvalidNumberOfOperands(instruction, 1);
            return false;
        }
        ExpressionPtr operand = instruction->operands[0];
        if (operand->type != OperandType::MemoryOperand && operand->type != OperandType::RegisterOperand) {
            instruction->diagnostic = reportExpressionMustBeMemoryOrRegisterOperand(operand);
            return false;
        }
        if (!operand->size) {
            instruction->diagnostic = reportExpressionMustHaveSize(operand);
            return false;
        }
    } else if (mnemonic == "INCHAR") {
        if (instruction->operands.size() != 1) {
            instruction->diagnostic = reportInvalidNumberOfOperands(instruction, 1);
            return false;
        }
        ExpressionPtr operand = instruction->operands[0];
        if (operand->type != OperandType::MemoryOperand && operand->type != OperandType::RegisterOperand) {
            instruction->diagnostic = reportExpressionMustBeMemoryOrRegisterOperand(operand);
            return false;
        }
        if (!operand->size) {
            instruction->diagnostic = reportExpressionMustHaveSize(operand);
            return false;
        }
        int operandSize = operand->size.value().value;
        if (operandSize != 1 && !operand->unresolvedSymbols) {
            instruction->diagnostic = reportInvalidOperandSize(operand, "1", operandSize);
            return false;
        }
    }
    return true;
}

bool SemanticAnalyzer::visitDirective(const std::shared_ptr<Directive> &directive)
{
    if (auto segDir = std::dynamic_pointer_cast<SegDir>(directive)) {
        return visitSegDir(segDir);
    } else if (auto dataDir = std::dynamic_pointer_cast<DataDir>(directive)) {
        return visitDataDir(dataDir);
    } else if (auto structDir = std::dynamic_pointer_cast<StructDir>(directive)) {
        return visitStructDir(structDir);
    } else if (auto procDir = std::dynamic_pointer_cast<ProcDir>(directive)) {
        return visitProcDir(procDir);
    } else if (auto recordDir = std::dynamic_pointer_cast<RecordDir>(directive)) {
        return visitRecordDir(recordDir);
    } else if (auto equDir = std::dynamic_pointer_cast<EquDir>(directive)) {
        return visitEquDir(equDir);
    } else if (auto equalDir = std::dynamic_pointer_cast<EqualDir>(directive)) {
        return visitEqualDir(equalDir);
    } else if (auto endDir = std::dynamic_pointer_cast<EndDir>(directive)) {
        return visitEndDir(endDir);
    } else {
        LOG_DETAILED_ERROR("Unknown directive type.");
        return false;
    }
}

bool SemanticAnalyzer::visitSegDir(const std::shared_ptr<SegDir> &segDir)
{
    if (segDir->constExpr) {
        bool success = visitExpression(segDir->constExpr.value(), ExpressionContext(ExprCtxtFlags::None));
        // TODO: checl that expr is constant
        if (!success) {
            segDir->diagnostic = segDir->constExpr.value()->diagnostic;
            return false;
        }
    }
    return true;
}

bool SemanticAnalyzer::visitDataDir(const std::shared_ptr<DataDir> &dataDir, const std::optional<Token> &strucNameToken)
{
    if (dataDir->idToken) {
        std::string fieldName = dataDir->idToken.value().lexeme;
        std::shared_ptr<DataVariableSymbol> dataVariableSymbol;
        if (strucNameToken) {
            std::shared_ptr<Symbol> symbol = parseSess->symbolTable->findSymbol(strucNameToken.value());
            auto structSymbol = std::dynamic_pointer_cast<StructSymbol>(symbol);
            dataVariableSymbol = structSymbol->namedFields[fieldName];
        } else {
            std::shared_ptr<Symbol> fieldSymbol = parseSess->symbolTable->findSymbol(fieldName);
            dataVariableSymbol = std::dynamic_pointer_cast<DataVariableSymbol>(fieldSymbol);
        }
        if (!dataVariableSymbol) {
            LOG_DETAILED_ERROR("no data variable symbol in the symbol table, when should be");
            return false;
        }
        dataVariableSymbol->value = -1; // TODO: calculate actual value
        dataVariableSymbol->wasDefined = true;
        return visitDataItem(dataDir->dataItem, dataVariableSymbol);
    }
    return visitDataItem(dataDir->dataItem, std::nullopt);
}

bool SemanticAnalyzer::visitStructDir(const std::shared_ptr<StructDir> &structDir)
{
    std::shared_ptr<Symbol> symbol = parseSess->symbolTable->findSymbol(structDir->firstIdToken);
    auto structSymbol = std::dynamic_pointer_cast<StructSymbol>(symbol);
    structSymbol->structDir = structDir;

    for (const auto &field : structDir->fields) {
        if (INVALID(field)) {
            continue;
        }
        std::ignore = visitDataDir(field, structDir->firstIdToken);
    }

    structSymbol->size = structSymbol->sizeOf = -1; // TODO: calculate actual value
    structSymbol->wasDefined = true;
    return true;
}

bool SemanticAnalyzer::visitProcDir(const std::shared_ptr<ProcDir> &procDir)
{
    for (const auto &instruction : procDir->instructions) {
        std::ignore = visitInstruction(instruction);
    }

    std::shared_ptr<Symbol> symbol = parseSess->symbolTable->findSymbol(procDir->firstIdToken);
    auto procSymbol = std::dynamic_pointer_cast<ProcSymbol>(symbol);
    procSymbol->value = -1; // TODO: calculate actual value
    procSymbol->wasDefined = true;
    return true;
}

bool SemanticAnalyzer::visitRecordDir(const std::shared_ptr<RecordDir> &recordDir)
{
    int32_t width = 0;
    for (const auto &field : recordDir->fields) {
        bool success = visitRecordField(field);
        if (!success) {
            recordDir->diagnostic = field->diagnostic;
            return false;
        }
        std::shared_ptr<Symbol> symbol = parseSess->symbolTable->findSymbol(field->fieldToken);
        auto recordFieldSymbol = std::dynamic_pointer_cast<RecordFieldSymbol>(symbol);
        width += recordFieldSymbol->width;
    }

    if (width > 32) {
        recordDir->diagnostic = reportRecordWidthTooBig(recordDir, width);
        return false;
    }

    std::shared_ptr<Symbol> symbol = parseSess->symbolTable->findSymbol(recordDir->idToken);
    auto recordSymbol = std::dynamic_pointer_cast<RecordSymbol>(symbol);
    recordSymbol->width = width;
    recordSymbol->wasDefined = true;
    // TODO: calculate mask

    return true;
}

bool SemanticAnalyzer::visitRecordField(const std::shared_ptr<RecordField> &recordField)
{
    std::shared_ptr<Symbol> symbol = parseSess->symbolTable->findSymbol(recordField->fieldToken);
    auto recordFieldSymbol = std::dynamic_pointer_cast<RecordFieldSymbol>(symbol);

    bool success = visitExpression(recordField->width, ExpressionContext(ExprCtxtFlags::None));
    if (!success) {
        recordField->diagnostic = recordField->width->diagnostic;
        return false;
    }

    if (!recordField->width->constantValue) {
        recordField->diagnostic = reportExpressionMustBeConstant(recordField->width);
        return false;
    }

    int64_t width = recordField->width->constantValue.value();
    if (width <= 0) {
        recordField->diagnostic = reportRecordFieldWidthMustBePositive(recordField, width);
        return false;
    }
    if (width > 31) {
        recordField->diagnostic = reportRecordFieldWidthTooBig(recordField, width);
        return false;
    }
    recordFieldSymbol->width = static_cast<int32_t>(width);

    auto initialValueExpr = recordField->initialValue;
    if (initialValueExpr) {
        success = visitExpression(initialValueExpr.value(), ExpressionContext(ExprCtxtFlags::None));
        if (!success) {
            recordField->diagnostic = initialValueExpr.value()->diagnostic;
            return false;
        }

        if (!initialValueExpr.value()->constantValue) {
            recordField->diagnostic = reportExpressionMustBeConstant(initialValueExpr.value());
            return false;
        }
        // int64_t initialValue = initialValueExpr.value()->constantValue.value();
        // TODO: check that initialValue fits into `width` bytes
    }
    // TODO: calculate shift & mask
    recordFieldSymbol->wasDefined = true;
    return true;
}

bool SemanticAnalyzer::visitEquDir(const std::shared_ptr<EquDir> &equDir)
{
    // TODO: can be a string
    std::shared_ptr<Symbol> symbol = parseSess->symbolTable->findSymbol(equDir->idToken);
    auto equSymbol = std::dynamic_pointer_cast<EquVariableSymbol>(symbol);
    bool success = visitExpression(equDir->value, ExpressionContext(ExprCtxtFlags::None));
    if (!success) {
        equDir->diagnostic = equDir->value->diagnostic;
        return false;
    }
    if (!equDir->value->constantValue) {
        equDir->diagnostic = reportExpressionMustBeConstant(equDir->value);
        return false;
    }
    // TODO: report when is' bigger than 32 bits
    equSymbol->value = static_cast<int32_t>(equDir->value->constantValue.value());
    equSymbol->wasDefined = true;
    return true;
}

bool SemanticAnalyzer::visitEqualDir(const std::shared_ptr<EqualDir> &equalDir)
{
    std::shared_ptr<Symbol> symbol = parseSess->symbolTable->findSymbol(equalDir->idToken);
    auto equalSymbol = std::dynamic_pointer_cast<EqualVariableSymbol>(symbol);
    bool success = visitExpression(equalDir->value, ExpressionContext(ExprCtxtFlags::None));
    if (!success) {
        equalDir->diagnostic = equalDir->value->diagnostic;
        return false;
    }
    if (!equalDir->value->constantValue) {
        equalDir->diagnostic = reportExpressionMustBeConstant(equalDir->value);
        return false;
    }
    // TODO: report when is' bigger than 32 bits
    equalSymbol->value = static_cast<int32_t>(equalDir->value->constantValue.value());
    equalSymbol->wasDefined = true;
    return true;
}

bool SemanticAnalyzer::visitEndDir(const std::shared_ptr<EndDir> &endDir)
{
    if (endDir->addressExpr) {
        bool success = visitExpression(endDir->addressExpr.value(), ExpressionContext(ExprCtxtFlags::None));
        if (!success) {
            endDir->diagnostic = endDir->addressExpr.value()->diagnostic;
            return false;
        }
        // TODO: check it's address expression
    }
    return true;
}

bool SemanticAnalyzer::visitDataItem(const std::shared_ptr<DataItem> &dataItem,
                                     const std::optional<std::shared_ptr<DataVariableSymbol>> &dataVariableSymbol)
{
    Token dataTypeToken = dataItem->dataTypeToken;
    if (dataDirectives.contains(stringToUpper(dataTypeToken.lexeme))) {
        if (dataVariableSymbol) {
            std::string typeStr = dataDirectiveToSizeStr[stringToUpper(dataTypeToken.lexeme)];
            dataVariableSymbol.value()->dataTypeSize = OperandSize(typeStr, sizeStrToValue[typeStr]);
        }
        return visitInitValue(dataItem->initValues, dataVariableSymbol, dataTypeToken);
    }

    // only STRUC or RECORD from here
    std::shared_ptr<Symbol> dataTypeSymbol = parseSess->symbolTable->findSymbol(dataTypeToken);
    if (!dataTypeSymbol) {
        dataItem->diagnostic = reportUndefinedSymbol(dataTypeToken, false);
        return false;
    }
    if (!dataTypeSymbol->wasDefined) {
        dataItem->diagnostic = reportUndefinedSymbol(dataTypeToken, true);
        return false;
    }

    if (!std::dynamic_pointer_cast<StructSymbol>(dataTypeSymbol) && !std::dynamic_pointer_cast<RecordSymbol>(dataTypeSymbol)) {
        dataItem->diagnostic = reportInvalidDataType(dataItem);
        return false;
    }

    if (dataVariableSymbol) {
        if (auto structSymbol = std::dynamic_pointer_cast<StructSymbol>(dataTypeSymbol)) {
            dataVariableSymbol.value()->dataTypeSize = OperandSize(structSymbol->token.lexeme, structSymbol->size);
        } else if (auto recordSymbol = std::dynamic_pointer_cast<RecordSymbol>(dataTypeSymbol)) {
            dataVariableSymbol.value()->dataTypeSize = OperandSize(recordSymbol->token.lexeme, 4);
        }
    }

    return visitInitValue(dataItem->initValues, dataVariableSymbol, dataTypeToken);
}

bool SemanticAnalyzer::visitInitValue(const std::shared_ptr<InitValue> &initValue,
                                      const std::optional<std::shared_ptr<DataVariableSymbol>> &dataVariableSymbol, const Token &expectedTypeToken)
{
    dataInitializerDepth = 0;
    return visitInitValueHelper(initValue, dataVariableSymbol, expectedTypeToken);
}

bool SemanticAnalyzer::visitInitValueHelper(const std::shared_ptr<InitValue> &initValue,
                                            const std::optional<std::shared_ptr<DataVariableSymbol>> &dataVariableSymbol,
                                            const Token &expectedTypeToken)
{
    dataInitializerDepth++;
    if (auto dupOperator = std::dynamic_pointer_cast<DupOperator>(initValue)) {
        // TODO: dup operator can't be inside <> (<1 dup (2)>)
        bool success = visitExpression(dupOperator->repeatCount, ExpressionContext(ExprCtxtFlags::None));
        if (!success) {
            initValue->diagnostic = dupOperator->repeatCount->diagnostic;
            return false;
        }
        if (!dupOperator->repeatCount->constantValue) {
            initValue->diagnostic = reportExpressionMustBeConstant(dupOperator->repeatCount);
            return false;
        }

        return visitInitValueHelper(dupOperator->operands, dataVariableSymbol, expectedTypeToken);

    } else if (auto questionMarkInitValue = std::dynamic_pointer_cast<QuestionMarkInitValue>(initValue)) {
        // Uninitialized data; no action needed

    } else if (auto expressionInitValue = std::dynamic_pointer_cast<ExpressionInitValue>(initValue)) {
        if (!dataDirectives.contains(stringToUpper(expectedTypeToken.lexeme))) {
            initValue->diagnostic = reportExpectedStrucOrRecordDataInitializer(expressionInitValue, expectedTypeToken);
            return false;
        }

        bool success = visitExpression(expressionInitValue->expr, ExpressionContext(ExprCtxtFlags::AllowForwardReferences));
        if (!success) {
            initValue->diagnostic = expressionInitValue->expr->diagnostic;
            return false;
        }

        // TODO: check for size

    } else if (auto structOrRecordInitValue = std::dynamic_pointer_cast<StructOrRecordInitValue>(initValue)) {
        if (dataDirectives.contains(stringToUpper(expectedTypeToken.lexeme))) {
            initValue->diagnostic = reportExpectedSingleItemDataInitializer(structOrRecordInitValue, expectedTypeToken);
            return false;
        }

        std::shared_ptr<Symbol> symbol = parseSess->symbolTable->findSymbol(expectedTypeToken);

        if (auto expectedRecordSymbol = std::dynamic_pointer_cast<RecordSymbol>(symbol)) {
            if (structOrRecordInitValue->initList->fields.size() > expectedRecordSymbol->fields.size()) {
                initValue->diagnostic = reportTooManyInitialValuesForRecord(structOrRecordInitValue, expectedRecordSymbol);
                return false;
            }

            for (const auto &init : structOrRecordInitValue->initList->fields) {
                std::shared_ptr<ExpressionInitValue> exprInitValue;
                if (!(exprInitValue = std::dynamic_pointer_cast<ExpressionInitValue>(init))) {
                    initValue->diagnostic = reportExpectedSingleItemDataInitializer(init, expectedTypeToken);
                    return false;
                }
                // TODO: check that for size
            }
        } else if (auto expectedStructSymbol = std::dynamic_pointer_cast<StructSymbol>(symbol)) {

            if (structOrRecordInitValue->initList->fields.size() > expectedStructSymbol->structDir->fields.size()) {
                initValue->diagnostic = reportTooManyInitialValuesForStruc(structOrRecordInitValue, expectedStructSymbol);
                return false;
            }
            int i = 0;
            for (const auto &init : structOrRecordInitValue->initList->fields) {
                Token newExpectedTypeToken = expectedStructSymbol->structDir->fields[i]->dataItem->dataTypeToken;

                if (std::dynamic_pointer_cast<DupOperator>(init)) {
                    if (dataDirectives.contains(stringToUpper(newExpectedTypeToken.lexeme))) {
                        initValue->diagnostic = reportExpectedSingleItemDataInitializer(init, newExpectedTypeToken);
                        return false;
                    } else {
                        initValue->diagnostic = reportExpectedStrucOrRecordDataInitializer(init, newExpectedTypeToken);
                        return false;
                    }
                }

                bool success = visitInitValueHelper(init, dataVariableSymbol, newExpectedTypeToken);
                if (!success) {
                    initValue->diagnostic = init->diagnostic;
                    return false;
                }
                i += 1;
            }
        }

    } else if (auto initList = std::dynamic_pointer_cast<InitializerList>(initValue)) {
        for (const auto &init : initList->fields) {
            bool success = visitInitValueHelper(init, dataVariableSymbol, expectedTypeToken);
            if (!success) {
                initValue->diagnostic = init->diagnostic;
                return false;
            }
        }
    } else {
        LOG_DETAILED_ERROR("Unknown initialization value type.");
        return false;
    }
    dataInitializerDepth--;
    return true;
}

bool SemanticAnalyzer::visitExpression(const ExpressionPtr &node, const ExpressionContext &context)
{
    expressionDepth = 0;
    return visitExpressionHelper(node, context);
}

bool SemanticAnalyzer::visitExpressionHelper(const ExpressionPtr &node, const ExpressionContext &context)
{
    bool result = false;
    expressionDepth++;
    if (auto brackets = std::dynamic_pointer_cast<Brackets>(node)) {
        result = visitBrackets(brackets, context);
    } else if (auto squareBrackets = std::dynamic_pointer_cast<SquareBrackets>(node)) {
        result = visitSquareBrackets(squareBrackets, context);
    } else if (auto implicitPlus = std::dynamic_pointer_cast<ImplicitPlusOperator>(node)) {
        result = visitImplicitPlusOperator(implicitPlus, context);
    } else if (auto binaryOp = std::dynamic_pointer_cast<BinaryOperator>(node)) {
        result = visitBinaryOperator(binaryOp, context);
    } else if (auto unaryOp = std::dynamic_pointer_cast<UnaryOperator>(node)) {
        result = visitUnaryOperator(unaryOp, context);
    } else if (auto leaf = std::dynamic_pointer_cast<Leaf>(node)) {
        result = visitLeaf(leaf, context);
    } else {
        LOG_DETAILED_ERROR("Unknown expression ptr node");
    }
    expressionDepth--;
    return result;
}

bool SemanticAnalyzer::visitBrackets(const std::shared_ptr<Brackets> &node, const ExpressionContext &context)
{
    bool success = visitExpressionHelper(node->operand, context);
    if (!success) {
        node->diagnostic = node->operand->diagnostic;
        return false;
    }

    auto operand = node->operand;
    node->unresolvedSymbols = operand->unresolvedSymbols;

    node->constantValue = operand->constantValue;
    node->isRelocatable = operand->isRelocatable;
    node->type = operand->type;
    node->size = operand->size;
    node->registers = operand->registers;
    return true;
}

bool SemanticAnalyzer::visitSquareBrackets(const std::shared_ptr<SquareBrackets> &node, const ExpressionContext &context)
{
    bool success = visitExpressionHelper(node->operand, context);
    if (!success) {
        node->diagnostic = node->operand->diagnostic;
        return false;
    }

    auto operand = node->operand;
    node->unresolvedSymbols = operand->unresolvedSymbols;

    node->constantValue = operand->constantValue;
    node->isRelocatable = operand->isRelocatable;
    if (operand->type == OperandType::UnfinishedMemoryOperand) {
        // check we only have 32 bit regsiters, and dont have 2 esp
        // delay checking for this, because for (esp + esp) we want to report can have registers in expressions
        // dont want to call this (reportInvalidAddressExpression())
        bool implicit = false;
        ExpressionPtr expr;
        std::shared_ptr<BinaryOperator> binOp;
        std::shared_ptr<ImplicitPlusOperator> implicitPlusOp;
        if ((binOp = std::dynamic_pointer_cast<BinaryOperator>(operand))) {
            implicit = false;
            // Check that we have [eax * 5] in []
            if (binOp->op.lexeme == "+") {
                bool firstIsRegisterWithOptionalScale = binOp->left->type == OperandType::RegisterOperand;
                if (auto binOpLeft = std::dynamic_pointer_cast<BinaryOperator>(binOp->left)) {
                    if (binOpLeft->op.lexeme == "*" &&
                        (binOpLeft->left->type == OperandType::RegisterOperand || binOpLeft->right->type == OperandType::RegisterOperand)) {
                        firstIsRegisterWithOptionalScale = true;
                    }
                }
                bool firstIsConstant = bool(binOp->left->constantValue);
                bool secondIsRegisterWithOptionalScale = binOp->right->type == OperandType::RegisterOperand;
                if (auto binOpRight = std::dynamic_pointer_cast<BinaryOperator>(binOp->right)) {
                    if (binOpRight->op.lexeme == "*" &&
                        (binOpRight->left->type == OperandType::RegisterOperand || binOpRight->right->type == OperandType::RegisterOperand)) {
                        secondIsRegisterWithOptionalScale = true;
                    }
                }
                bool secondIsConstant = bool(binOp->right->constantValue);
                if ((firstIsConstant && secondIsRegisterWithOptionalScale) || (firstIsRegisterWithOptionalScale && secondIsConstant)) {
                    // allowed
                } else {
                    node->diagnostic = reportNonRegisterInSquareBrackets(binOp);
                    return false;
                }
            } else if (binOp->op.lexeme != "*") {
                node->diagnostic = reportNonRegisterInSquareBrackets(binOp);
                return false;
            }
            expr = binOp;
        } else if ((implicitPlusOp = std::dynamic_pointer_cast<ImplicitPlusOperator>(operand))) {
            // report error, beacuse can't have [[eax][ebx]]
            node->diagnostic = reportNonRegisterInSquareBrackets(binOp);
            return false;
        } else {
            LOG_DETAILED_ERROR("Unexpected operand type!\n");
        }
        bool non32bitRegister = false;
        int espCount = 0;
        for (const auto &[regToken, scale] : operand->registers) {
            if (registerSizes[stringToUpper(regToken.lexeme)] != 4) {
                non32bitRegister = true;
            }
            if (stringToUpper(regToken.lexeme) == "ESP") {
                espCount += 1;
            }
        }

        if (non32bitRegister) {
            node->diagnostic = reportNon32bitRegister(expr, implicit);
            return false;
        }
        if (espCount == 2) {
            node->diagnostic = reportTwoEsp(expr, implicit);
            return false;
        }
        node->type = OperandType::MemoryOperand;
    } else if (operand->type == OperandType::RegisterOperand) {
        bool non32bitRegister = false;
        for (const auto &[regToken, scale] : operand->registers) {
            if (registerSizes[stringToUpper(regToken.lexeme)] != 4) {
                non32bitRegister = true;
            }
        }
        if (non32bitRegister) {
            node->diagnostic = reportNon32bitRegister(operand, true);
            return false;
        }
        node->type = OperandType::MemoryOperand;
    } else {
        node->type = operand->type;
    }
    if (operand->registers.empty()) {
        node->size = operand->size;
    } else {
        // modificators reset known size
        node->size = std::nullopt;
    }
    node->registers = operand->registers;
    return true;
}

bool SemanticAnalyzer::visitImplicitPlusOperator(const std::shared_ptr<ImplicitPlusOperator> &node, const ExpressionContext &context)
{
    bool success = visitExpressionHelper(node->left, context);
    if (!success) {
        node->diagnostic = node->left->diagnostic;
        return false;
    }
    success = visitExpressionHelper(node->right, context);
    if (!success) {
        node->diagnostic = node->right->diagnostic;
        return false;
    }

    auto left = node->left;
    auto right = node->right;
    node->unresolvedSymbols = left->unresolvedSymbols || right->unresolvedSymbols;

    if (left->isRelocatable && right->isRelocatable) {
        node->diagnostic = reportCantAddVariables(node, true);
        return false;
    }
    // check that we have not more then 2 registers, and only one has scale (eax * 1) is counted as having scale
    if (left->registers.size() + right->registers.size() > 2) {
        node->diagnostic = reportMoreThanTwoRegistersAfterAdd(node, true);
        return false;
    }

    auto newRegisters = left->registers;
    for (const auto &[regToken, scale] : right->registers) {
        newRegisters[regToken] = scale;
    }
    // ensure only one has scale
    int scaleCount = 0;
    for (const auto &[regToken, scale] : newRegisters) {
        if (newRegisters[regToken].has_value()) {
            scaleCount += 1;
        }
    }
    if (scaleCount > 1) {
        node->diagnostic = reportMoreThanOneScaleAfterAdd(node, true);
        return false;
    }

    // check we only have 32 bit regsiters, and dont have 2 esp
    // in implicit plus - need to check immediately
    // to detect [esp][esp]
    // for esp + esp - want to have error - can't have regsiters in expressions
    bool non32bitRegister = false;
    int espCount = 0;
    for (const auto &[regToken, scale] : newRegisters) {
        if (registerSizes[stringToUpper(regToken.lexeme)] != 4) {
            non32bitRegister = true;
        }
        if (stringToUpper(regToken.lexeme) == "ESP") {
            espCount += 1;
        }
    }

    if (non32bitRegister) {
        node->diagnostic = reportNon32bitRegister(node, true);
        return false;
    }
    if (espCount == 2) {
        node->diagnostic = reportTwoEsp(node, true);
        return false;
    }

    if (left->constantValue && right->constantValue) {
        node->constantValue = left->constantValue.value() + right->constantValue.value();
    } else {
        node->constantValue = std::nullopt;
    }
    node->isRelocatable = left->isRelocatable || right->isRelocatable;

    if (left->type == OperandType::ImmediateOperand && right->type == OperandType::ImmediateOperand) {
        node->type = OperandType::ImmediateOperand;
    } else if (left->type == OperandType::RegisterOperand || right->type == OperandType::RegisterOperand) {
        node->type = OperandType::UnfinishedMemoryOperand;
    } else if (left->type == OperandType::UnfinishedMemoryOperand || right->type == OperandType::UnfinishedMemoryOperand) {
        node->type = OperandType::UnfinishedMemoryOperand;
    } else if (left->type == OperandType::MemoryOperand || right->type == OperandType::MemoryOperand) {
        node->type = OperandType::MemoryOperand;
    } else {
        LOG_DETAILED_ERROR("Unhandled operand type combination in ImplicitPlus");
    }

    if (!left->size && !right->size) {
        node->size = std::nullopt;
    } else if (left->size && !right->size) {
        node->size = left->size;
    } else if (!left->size && right->size) {
        node->size = right->size;
    } else {
        // TODO: report that operands have different sizes
        // for example (byte PTR testvar)(dword PTR [eax])
        node->size = left->size;
    }
    node->registers = newRegisters;
    return true;
}

bool SemanticAnalyzer::visitBinaryOperator(const std::shared_ptr<BinaryOperator> &node, const ExpressionContext &context)
{
    ExpressionContext contextLeft = context;
    ExpressionContext contextRight = context;
    if (node->op.lexeme == ".") {
        contextRight.isStructField = true;
    }

    bool success = visitExpressionHelper(node->left, contextLeft);
    if (!success) {
        node->diagnostic = node->left->diagnostic;
        return false;
    }
    success = visitExpressionHelper(node->right, contextRight);
    if (!success) {
        node->diagnostic = node->right->diagnostic;
        return false;
    }

    std::string op = stringToUpper(node->op.lexeme);
    auto left = node->left;
    auto right = node->right;
    node->unresolvedSymbols = left->unresolvedSymbols || right->unresolvedSymbols;

    if (op == ".") {
        if (left->type == OperandType::UnfinishedMemoryOperand) {
            node->diagnostic = reportCantHaveRegistersInExpression(left);
            return false;
        } else if (right->type == OperandType::UnfinishedMemoryOperand) {
            node->diagnostic = reportCantHaveRegistersInExpression(right);
            return false;
        }
        if (left->type != OperandType::MemoryOperand) {
            node->diagnostic = reportDotOperatorIncorrectArgument(node);
            return false;
        }
        std::shared_ptr<Leaf> leafRight;
        if (!(leafRight = std::dynamic_pointer_cast<Leaf>(right)) || leafRight->token.type != TokenType::Identifier) {
            LOG_DETAILED_ERROR("After `.` encountered not an identifier! (should be handled in the parsing stage)");
            return false;
        }

        if (!left->size) {
            node->diagnostic = reportDotOperatorSizeNotSpecified(node);
            return false;
        }
        std::shared_ptr<Symbol> typeSymbol = parseSess->symbolTable->findSymbol(left->size->symbol);
        if (!typeSymbol || !std::dynamic_pointer_cast<StructSymbol>(typeSymbol)) {
            node->diagnostic = reportDotOperatorTypeNotStruct(node, left->size->symbol);
            return false;
        }
        auto structSymbol = std::dynamic_pointer_cast<StructSymbol>(typeSymbol);
        if (!structSymbol->namedFields.contains(leafRight->token.lexeme)) {
            node->diagnostic = reportDotOperatorFieldDoesntExist(node, structSymbol->token.lexeme, leafRight->token.lexeme);
            return false;
        }

        node->constantValue = std::nullopt;
        node->isRelocatable = left->isRelocatable;
        node->type = OperandType::MemoryOperand;

        // Forward references must be allowed (when not allowed, the expression also must be constant and for `.` error expression must be constant
        // will be emitted)
        // TODO: test this...
        if (!structSymbol->wasDefined) {
            linesForSecondPass.push_back(currentLine);
            node->unresolvedSymbols = true;
        }
        node->size = structSymbol->namedFields[leafRight->token.lexeme]->dataTypeSize;
        node->registers = left->registers;
        return true;
    } else if (op == "PTR") {
        if (left->type == OperandType::UnfinishedMemoryOperand) {
            node->diagnostic = reportCantHaveRegistersInExpression(left);
            return false;
        } else if (right->type == OperandType::UnfinishedMemoryOperand) {
            node->diagnostic = reportCantHaveRegistersInExpression(right);
            return false;
        }
        std::shared_ptr<Leaf> leafLeft;
        if (!(leafLeft = std::dynamic_pointer_cast<Leaf>(left)) ||
            !(leafLeft->token.type == TokenType::Type || leafLeft->token.type == TokenType::Identifier) ||
            right->type == OperandType::RegisterOperand) {
            node->diagnostic = reportPtrOperatorIncorrectArgument(node);
            return false;
        }

        std::string typeOperand = leafLeft->token.lexeme;
        std::shared_ptr<Symbol> typeSymbol;
        if (!builtinTypes.contains(stringToUpper(typeOperand))) {
            typeSymbol = parseSess->symbolTable->findSymbol(leafLeft->token);
            if (!typeSymbol || !std::dynamic_pointer_cast<StructSymbol>(typeSymbol)) {
                node->diagnostic = reportPtrOperatorIncorrectArgument(node);
                return false;
            }
        }
        if (builtinTypes.contains(stringToUpper(typeOperand))) {
            typeOperand = stringToUpper(typeOperand);
        }

        node->constantValue = right->constantValue;
        node->isRelocatable = right->isRelocatable;
        node->type = right->type;
        if (builtinTypes.contains(typeOperand)) {
            node->size = OperandSize(typeOperand, sizeStrToValue[typeOperand]);
        } else {
            auto structSymbol = std::dynamic_pointer_cast<StructSymbol>(typeSymbol);
            node->size = OperandSize(typeOperand, structSymbol->size);
        }

        node->registers = right->registers;
        return true;

    } else if (op == "*" || op == "/" || op == "MOD" || op == "SHL" || op == "SHR") {
        // can check this immediately cause eax * 4, eax is RegisterOperand
        if (left->type == OperandType::UnfinishedMemoryOperand) {
            node->diagnostic = reportCantHaveRegistersInExpression(left);
            return false;
        } else if (right->type == OperandType::UnfinishedMemoryOperand) {
            node->diagnostic = reportCantHaveRegistersInExpression(right);
            return false;
        }
        // handle eax * 4
        if (op == "*") {
            if ((left->constantValue && right->type == OperandType::RegisterOperand) ||
                (right->constantValue && left->type == OperandType::RegisterOperand)) {
                int64_t value = 0;
                std::shared_ptr<Leaf> leafNode;
                if (left->constantValue) {
                    value = left->constantValue.value();
                    leafNode = std::dynamic_pointer_cast<Leaf>(right);
                } else {
                    value = right->constantValue.value();
                    leafNode = std::dynamic_pointer_cast<Leaf>(left);
                }
                if (value != 1 && value != 2 && value != 4 && value != 8 && !node->unresolvedSymbols) {
                    node->diagnostic = reportInvalidScaleValue(node);
                    return false;
                }
                if (stringToUpper(leafNode->token.lexeme) == "ESP") {
                    node->diagnostic = reportIncorrectIndexRegister(leafNode);
                    return false;
                }

                node->constantValue = std::nullopt;
                node->isRelocatable = false;
                node->type = OperandType::UnfinishedMemoryOperand;
                node->size = std::nullopt;
                if (left->type == OperandType::RegisterOperand) {
                    std::shared_ptr<Leaf> leftLeaf = std::dynamic_pointer_cast<Leaf>(left);
                    node->registers[leftLeaf->token] = static_cast<int32_t>(value);
                } else {
                    std::shared_ptr<Leaf> rightLeaf = std::dynamic_pointer_cast<Leaf>(right);
                    node->registers[rightLeaf->token] = static_cast<int32_t>(value);
                }
                return true;
            }
        }
        if (left->constantValue && right->constantValue) {
            if (op == "*") {
                node->constantValue = left->constantValue.value() * right->constantValue.value();
            } else if (op == "/") {
                if (right->constantValue.value() == 0 && !node->unresolvedSymbols) {
                    node->diagnostic = reportDivisionByZero(node);
                    return false;
                }
                if (node->unresolvedSymbols) {
                    node->constantValue = -1;
                } else {
                    node->constantValue = left->constantValue.value() / right->constantValue.value();
                }
            } else if (op == "MOD") {
                if (right->constantValue.value() == 0 && !node->unresolvedSymbols) {
                    node->diagnostic = reportDivisionByZero(node);
                    return false;
                }
                if (node->unresolvedSymbols) {
                    node->constantValue = -1;
                } else {
                    node->constantValue = left->constantValue.value() % right->constantValue.value();
                }
            } else if (op == "SHL") {
                // TODO: calculate SHL
                node->unresolvedSymbols = true;
                node->constantValue = -1;
            } else if (op == "SHR") {
                // TODO: calculate SHR
                node->unresolvedSymbols = true;
                node->constantValue = -1;
            }

            node->constantValue = right->constantValue;
            node->isRelocatable = right->isRelocatable;
            node->type = right->type;
            node->size = OperandSize("DWORD", 4);
            node->registers = left->registers;
            return true;
        }

        node->diagnostic = reportOtherBinaryOperatorIncorrectArgument(node);
        return false;
    } else if (op == "+") {
        if (left->isRelocatable && right->isRelocatable) {
            node->diagnostic = reportCantAddVariables(node, false);
            return false;
        }
        // check that we have not more then 2 registers, and only one has scale (eax * 1) is counted as having scale
        // Not needed now, because [eax + ebx] is forbidden (only one register inside [])
        // later the error CANT_HAVE_REGISTERS_IN_EXPRESSION will be emitted
        {
            // if (left->registers.size() + right->registers.size() > 2) {
            //     node->type = OperandType::InvalidOperand;
            //     reportMoreThanTwoRegistersAfterAdd(node, false);
            //     return;
            // }

            // auto newRegisters = left->registers;
            // for (const auto &[regToken, scale] : right->registers) {
            //     newRegisters[regToken] = scale;
            // }
            // // ensure only one has scale
            // int scaleCount = 0;
            // for (const auto &[regToken, scale] : newRegisters) {
            //     if (newRegisters[regToken].has_value()) {
            //         scaleCount += 1;
            //     }
            // }
            // if (scaleCount > 1) {
            //     node->type = OperandType::InvalidOperand;
            //     reportMoreThanOneScaleAfterAdd(node, false);
            //     return;
            // }
        }
        // check we only have 32 bit regsiters, and dont have 2 esp
        // checking for this is delayed until operator []
        if (left->constantValue && right->constantValue) {
            node->constantValue = left->constantValue.value() + right->constantValue.value();
        } else {
            node->constantValue = std::nullopt;
        }
        node->isRelocatable = left->isRelocatable || right->isRelocatable;

        if (left->type == OperandType::ImmediateOperand && right->type == OperandType::ImmediateOperand) {
            node->type = OperandType::ImmediateOperand;
        } else if (left->type == OperandType::RegisterOperand || right->type == OperandType::RegisterOperand) {
            node->type = OperandType::UnfinishedMemoryOperand;
        } else if (left->type == OperandType::UnfinishedMemoryOperand || right->type == OperandType::UnfinishedMemoryOperand) {
            node->type = OperandType::UnfinishedMemoryOperand;
        } else if (left->type == OperandType::MemoryOperand || right->type == OperandType::MemoryOperand) {
            node->type = OperandType::MemoryOperand;
        } else {
            LOG_DETAILED_ERROR("Unhandled operand type combination in `+`");
        }

        if (!left->size && !right->size) {
            node->size = std::nullopt;
        } else if (left->size && !right->size) {
            node->size = left->size;
        } else if (!left->size && right->size) {
            node->size = right->size;
        } else {
            // TODO: report that operands have different sizes
            // for example (byte PTR testvar)(dword PTR [eax])
            node->size = left->size;
        }

        auto newRegisters = left->registers;
        for (const auto &[regToken, scale] : right->registers) {
            newRegisters[regToken] = scale;
        }
        node->registers = newRegisters;
        return true;
    } else if (op == "-") {
        if (!(left->registers.empty() && left->isRelocatable) && !right->constantValue) {
            // need to check this after, cause after `-` can still be UnsinishedMemoryOperand
            if (left->type == OperandType::UnfinishedMemoryOperand) {
                node->diagnostic = reportCantHaveRegistersInExpression(left);
                return false;
            } else if (right->type == OperandType::UnfinishedMemoryOperand) {
                node->diagnostic = reportCantHaveRegistersInExpression(right);
                return false;
            }
            node->diagnostic = reportBinaryMinusOperatorIncorrectArgument(node);
            return false;
        }

        if (left->registers.empty() && left->isRelocatable) {
            // left is an adress expression, right can be an address expression or constant
            if (right->constantValue) {
                node->constantValue = left->constantValue.value() - right->constantValue.value();
                node->isRelocatable = false;
                node->type = OperandType::ImmediateOperand;
                node->size = std::nullopt;
                node->registers = {};
                return true;
            } else if (right->isRelocatable && right->registers.empty()) {
                node->unresolvedSymbols = true;
                node->constantValue = -1; // TODO: calculate actual constant value of the differece between 2 relocations
                node->isRelocatable = false;
                node->type = OperandType::ImmediateOperand;
                node->size = std::nullopt;
                node->registers = {};
                return true;
            }
        }
        // left is not an adress expression, right must be constant
        else if (right->constantValue) {
            if (left->constantValue) {
                node->constantValue = left->constantValue.value() - right->constantValue.value();
            } else {
                node->constantValue = left->constantValue;
            }
            node->isRelocatable = left->isRelocatable;
            if (left->type == OperandType::RegisterOperand) {
                node->type = OperandType::UnfinishedMemoryOperand;
            } else {
                node->type = left->type;
            }
            node->size = left->size;
            node->registers = left->registers;
            return true;
        }
    } else {
        LOG_DETAILED_ERROR("Unknown binary operator!");
    }
    return true;
}

bool SemanticAnalyzer::visitUnaryOperator(const std::shared_ptr<UnaryOperator> &node, const ExpressionContext &context)
{
    std::string op = stringToUpper(node->op.lexeme);
    bool success = visitExpressionHelper(node->operand, context);
    if (!success) {
        node->diagnostic = node->operand->diagnostic;
        return false;
    }

    auto operand = node->operand;
    node->unresolvedSymbols = operand->unresolvedSymbols;

    if (operand->type == OperandType::UnfinishedMemoryOperand) {
        node->diagnostic = reportCantHaveRegistersInExpression(operand);
        return false;
    }

    if (op == "LENGTH" || op == "LENGTHOF") {
        std::shared_ptr<Leaf> leaf;
        // operand must be identifier
        if (!(leaf = std::dynamic_pointer_cast<Leaf>(operand)) || leaf->token.type != TokenType::Identifier) {
            node->diagnostic = reportUnaryOperatorIncorrectArgument(node);
            return false;
        }
        // LENGTH(OF) doesn't work with StructSymbol, RecordSymbol, RecordFieldSymbol
        std::shared_ptr<Symbol> symbol = parseSess->symbolTable->findSymbol(leaf->token);
        if (std::dynamic_pointer_cast<StructSymbol>(symbol) || std::dynamic_pointer_cast<RecordSymbol>(symbol) ||
            std::dynamic_pointer_cast<RecordFieldSymbol>(symbol)) {
            node->diagnostic = reportUnaryOperatorIncorrectArgument(node);
            return false;
        }
        // TODO: calculate actual length
        // TODO: check whether symbol was defined
        node->unresolvedSymbols = true;
        node->constantValue = -1;
        node->isRelocatable = false;
        node->type = OperandType::ImmediateOperand;
        node->size = std::nullopt;
        node->registers = {};
    } else if (op == "SIZE" || op == "SIZEOF") {
        std::shared_ptr<Leaf> leaf;
        // operand must be identifier
        if (!(leaf = std::dynamic_pointer_cast<Leaf>(operand)) || leaf->token.type != TokenType::Identifier) {
            node->diagnostic = reportUnaryOperatorIncorrectArgument(node);
            return false;
        }
        // SIZE(OF) doesn't work with RecordFieldSymbol
        std::shared_ptr<Symbol> symbol = parseSess->symbolTable->findSymbol(leaf->token);
        if (std::dynamic_pointer_cast<RecordFieldSymbol>(symbol)) {
            node->diagnostic = reportUnaryOperatorIncorrectArgument(node);
            return false;
        }
        // TODO: calculate actual size
        // TODO: check whether symbol was defined
        node->unresolvedSymbols = true;
        node->constantValue = -1;
        node->isRelocatable = false;
        node->type = OperandType::ImmediateOperand;
        node->size = std::nullopt;
        node->registers = {};

    } else if (op == "WIDTH" || op == "MASK") {
        std::shared_ptr<Leaf> leaf;
        // operand must be identifier
        if (!(leaf = std::dynamic_pointer_cast<Leaf>(operand)) || leaf->token.type != TokenType::Identifier) {
            node->diagnostic = reportUnaryOperatorIncorrectArgument(node);
            return false;
        }
        // WIDTH and MASK work only with RecordSymbol or RecordFieldSymbol
        std::shared_ptr<Symbol> symbol = parseSess->symbolTable->findSymbol(leaf->token);
        if (!std::dynamic_pointer_cast<RecordSymbol>(symbol) && !std::dynamic_pointer_cast<RecordFieldSymbol>(symbol)) {
            node->diagnostic = reportUnaryOperatorIncorrectArgument(node);
            return false;
        }
        // TODO: calculate actual value
        // TODO: check whether symbol was defined
        node->unresolvedSymbols = true;
        node->constantValue = -1;
        node->isRelocatable = false;
        node->type = OperandType::ImmediateOperand;
        node->size = std::nullopt;
        node->registers = {};

    } else if (op == "OFFSET") {
        // operand must be adress expression (without registers)
        if (operand->constantValue || !operand->registers.empty()) {
            node->diagnostic = reportUnaryOperatorIncorrectArgument(node);
            return false;
        }
        node->constantValue = operand->constantValue;
        node->isRelocatable = operand->isRelocatable;
        node->type = OperandType::ImmediateOperand;
        node->size = operand->size;
        node->registers = operand->registers;

    } else if (op == "TYPE") {
        // work with everythings, but outputs 0 sometimes
        if (!operand->size) {
            node->constantValue = 0;
            warnTypeReturnsZero(node);
        } else {
            node->constantValue = operand->size.value().value;
        }
        node->isRelocatable = false;
        node->type = OperandType::ImmediateOperand;
        node->size = std::nullopt;
        node->registers = {};
        return true;
    } else if (op == "+" || op == "-") {
        // operand must be constant value
        if (!operand->constantValue) {
            node->diagnostic = reportUnaryOperatorIncorrectArgument(node);
            return false;
        }
        if (op == "-") {
            node->constantValue = -operand->constantValue.value();
        } else if (op == "+") {
            node->constantValue = operand->constantValue;
        }
        node->isRelocatable = false;
        node->type = OperandType::ImmediateOperand;
        node->size = std::nullopt;
        node->registers = {};
    } else {
        LOG_DETAILED_ERROR("Unknown unary operator!");
        return false;
    }
    return true;
}

bool SemanticAnalyzer::visitLeaf(const std::shared_ptr<Leaf> &node, const ExpressionContext &context)
{
    Token token = node->token;

    if (token.type == TokenType::Identifier) {
        if (context.isStructField) {
            // this is handled higher in the `.`
            node->type = OperandType::Unspecified;
            return true;
        }

        if (!parseSess->symbolTable->findSymbol(token)) {
            node->diagnostic = reportUndefinedSymbol(token, false);
            return false;
        }
        std::shared_ptr<Symbol> symbol = parseSess->symbolTable->findSymbol(token);
        if (!symbol->wasDefined && !context.allowForwardReferences) {
            node->diagnostic = reportUndefinedSymbol(token, true);
            return false;
        }

        if (!symbol->wasDefined) {
            linesForSecondPass.push_back(currentLine);
            node->unresolvedSymbols = true;
        }

        if (auto dataVariableSymbol = std::dynamic_pointer_cast<DataVariableSymbol>(symbol)) {
            std::string dataType = dataVariableSymbol->dataType.lexeme;
            node->constantValue = std::nullopt;
            node->isRelocatable = true;
            node->type = OperandType::MemoryOperand;
            node->size = dataVariableSymbol->dataTypeSize;
            node->registers = {};
        } else if (std::dynamic_pointer_cast<LabelSymbol>(symbol) || std::dynamic_pointer_cast<ProcSymbol>(symbol)) {
            node->constantValue = std::nullopt;
            node->isRelocatable = true;
            node->type = OperandType::MemoryOperand;
            node->size = OperandSize("DWORD", 4);
            node->registers = {};
        } else if (auto equVariableSymbol = std::dynamic_pointer_cast<EquVariableSymbol>(symbol)) {
            node->constantValue = equVariableSymbol->value;
            node->isRelocatable = false;
            node->type = OperandType::ImmediateOperand;
            node->size = std::nullopt;
            node->registers = {};
        } else if (auto equalVariableSymbol = std::dynamic_pointer_cast<EqualVariableSymbol>(symbol)) {
            node->constantValue = equalVariableSymbol->value;
            node->isRelocatable = false;
            node->type = OperandType::ImmediateOperand;
            node->size = std::nullopt;
            node->registers = {};
        } else if (auto structSymbol = std::dynamic_pointer_cast<StructSymbol>(symbol)) {
            node->constantValue = structSymbol->size;
            node->isRelocatable = false;
            node->type = OperandType::ImmediateOperand;
            node->size = std::nullopt;
            node->registers = {};
        } else if (auto recordSymbol = std::dynamic_pointer_cast<RecordSymbol>(symbol)) {
            node->constantValue = recordSymbol->mask;
            node->isRelocatable = false;
            node->type = OperandType::ImmediateOperand;
            node->size = std::nullopt;
            node->registers = {};
        } else if (auto recordFieldSymbol = std::dynamic_pointer_cast<RecordFieldSymbol>(symbol)) {
            node->constantValue = recordFieldSymbol->shift;
            node->isRelocatable = false;
            node->type = OperandType::ImmediateOperand;
            node->size = std::nullopt;
            node->registers = {};
        }

    } else if (token.type == TokenType::Number) {
        auto numberValue = parseNumber(token.lexeme);
        if (!numberValue) {
            node->diagnostic = reportNumberTooLarge(token);
            return false;
        }
        node->constantValue = static_cast<int64_t>(numberValue.value());
        node->isRelocatable = false;
        node->size = std::nullopt;
        node->type = OperandType::ImmediateOperand;
        node->registers = {};
    } else if (token.type == TokenType::StringLiteral) {
        // if expressionDepth == 1 in DataDefiniton context - string literal can be any length
        // any other - needs to be less than 4 bytes
        // size() + 2, because " " are in the lexeme
        if ((context.allowRegisters && token.lexeme.size() > 4 + 2) || (expressionDepth > 1 && token.lexeme.size() > 4 + 2)) {
            node->diagnostic = reportStringTooLarge(token);
            return false;
        }
        node->unresolvedSymbols = true;
        node->constantValue = -1; // TODO: convert string value to bytes and then to int32_t
        node->isRelocatable = false;
        node->size = std::nullopt;
        node->type = OperandType::ImmediateOperand;
        node->registers = {};
    } else if (token.type == TokenType::Register) {
        if (!context.allowRegisters) {
            node->diagnostic = reportRegisterNotAllowed(token);
            return false;
        }
        node->constantValue = std::nullopt;
        node->isRelocatable = false;
        int value = registerSizes[stringToUpper(token.lexeme)];
        node->size = OperandSize(sizeValueToStr[value], value);
        node->type = OperandType::RegisterOperand;
        node->registers[token] = std::nullopt;
    } else if (token.type == TokenType::Dollar) {
        node->constantValue = std::nullopt;
        node->isRelocatable = true;
        node->type = OperandType::ImmediateOperand;
        node->size = OperandSize("DWORD", 4);
        node->registers = {};
    } else if (token.type == TokenType::Type) {
        node->constantValue = sizeStrToValue[stringToUpper(token.lexeme)];
        node->isRelocatable = false;
        node->type = OperandType::ImmediateOperand;
        node->size = std::nullopt;
        node->registers = {};
    } else {
        LOG_DETAILED_ERROR("Unkown leaf token!");
        return false;
    }
    return true;
}

File semantic_analyzer.h:

#pragma once

#include "ast.h"
#include "symbol_table.h"
#include "diag_ctxt.h"
#include "log.h"
#include "session.h"
#include <unordered_set>

enum class ExprCtxtFlags {
    None = 0,
    AllowRegisters = 1 << 0,
    AllowForwardReferences = 1 << 1,
    IsStructField = 1 << 2,
};

inline ExprCtxtFlags operator|(ExprCtxtFlags a, ExprCtxtFlags b) { return static_cast<ExprCtxtFlags>(static_cast<int>(a) | static_cast<int>(b)); }

inline ExprCtxtFlags operator&(ExprCtxtFlags a, ExprCtxtFlags b) { return static_cast<ExprCtxtFlags>(static_cast<int>(a) & static_cast<int>(b)); }

struct ExpressionContext {
    explicit ExpressionContext(ExprCtxtFlags flags)
        : allowRegisters(bool(flags & ExprCtxtFlags::AllowRegisters)), isStructField(bool(flags & ExprCtxtFlags::IsStructField)),
          allowForwardReferences(bool(flags & ExprCtxtFlags::AllowForwardReferences))

    {
    }

    bool allowRegisters;
    bool isStructField;
    bool allowForwardReferences;
};

using DiagnosticPtr = std::shared_ptr<Diagnostic>;

class SemanticAnalyzer {
public:
    SemanticAnalyzer(std::shared_ptr<ParseSession> parseSession, ASTPtr ast);

    void analyze();

private:
    void visit(const ASTPtr &node);

    [[nodiscard]] bool visitStatement(const std::shared_ptr<Statement> &statement);
    [[nodiscard]] bool visitInstruction(const std::shared_ptr<Instruction> &instruction);
    [[nodiscard]] bool visitDirective(const std::shared_ptr<Directive> &directive);

    [[nodiscard]] bool visitSegDir(const std::shared_ptr<SegDir> &segDir);
    [[nodiscard]] bool visitDataDir(const std::shared_ptr<DataDir> &dataDir, const std::optional<Token> &strucNameToken = std::nullopt);
    [[nodiscard]] bool visitStructDir(const std::shared_ptr<StructDir> &structDir);
    [[nodiscard]] bool visitProcDir(const std::shared_ptr<ProcDir> &procDir);
    [[nodiscard]] bool visitRecordDir(const std::shared_ptr<RecordDir> &recordDir);
    [[nodiscard]] bool visitRecordField(const std::shared_ptr<RecordField> &recordField);
    [[nodiscard]] bool visitEquDir(const std::shared_ptr<EquDir> &equDir);
    [[nodiscard]] bool visitEqualDir(const std::shared_ptr<EqualDir> &equalDir);
    [[nodiscard]] bool visitEndDir(const std::shared_ptr<EndDir> &endDir);

    [[nodiscard]] bool visitDataItem(const std::shared_ptr<DataItem> &dataItem,
                                     const std::optional<std::shared_ptr<DataVariableSymbol>> &dataVariableSymbol);
    [[nodiscard]] bool visitInitValue(const std::shared_ptr<InitValue> &initValue,
                                      const std::optional<std::shared_ptr<DataVariableSymbol>> &dataVariableSymbol, const Token &expectedTypeToken);
    [[nodiscard]] bool visitInitValueHelper(const std::shared_ptr<InitValue> &initValue,
                                            const std::optional<std::shared_ptr<DataVariableSymbol>> &dataVariableSymbol,
                                            const Token &expectedTypeToken);

    // ASTexpression nodes
    [[nodiscard]] bool visitExpression(const ExpressionPtr &node, const ExpressionContext &context);
    [[nodiscard]] bool visitExpressionHelper(const ExpressionPtr &node, const ExpressionContext &context);
    [[nodiscard]] bool visitBrackets(const std::shared_ptr<Brackets> &node, const ExpressionContext &context);
    [[nodiscard]] bool visitSquareBrackets(const std::shared_ptr<SquareBrackets> &node, const ExpressionContext &context);
    [[nodiscard]] bool visitImplicitPlusOperator(const std::shared_ptr<ImplicitPlusOperator> &node, const ExpressionContext &context);
    [[nodiscard]] bool visitBinaryOperator(const std::shared_ptr<BinaryOperator> &node, const ExpressionContext &context);
    [[nodiscard]] bool visitUnaryOperator(const std::shared_ptr<UnaryOperator> &node, const ExpressionContext &context);
    [[nodiscard]] bool visitLeaf(const std::shared_ptr<Leaf> &node, const ExpressionContext &context);

    // DataItem errors
    [[nodiscard]] DiagnosticPtr reportInvalidDataType(const std::shared_ptr<DataItem> &dataItem);

    // InitValue errors
    [[nodiscard]] DiagnosticPtr reportExpectedStrucOrRecordDataInitializer(const std::shared_ptr<InitValue> &initValue,
                                                                           const Token &expectedTypeToken);
    [[nodiscard]] DiagnosticPtr reportExpectedSingleItemDataInitializer(const std::shared_ptr<InitValue> &initValue, const Token &expectedTypeToken);
    [[nodiscard]] DiagnosticPtr reportTooManyInitialValuesForRecord(const std::shared_ptr<InitValue> &initValue,
                                                                    const std::shared_ptr<RecordSymbol> &recordSymbol);
    [[nodiscard]] DiagnosticPtr reportTooManyInitialValuesForStruc(const std::shared_ptr<InitValue> &initValue,
                                                                   const std::shared_ptr<StructSymbol> &structSymbol);

    // Instruction errors
    [[nodiscard]] DiagnosticPtr reportInvalidNumberOfOperands(const std::shared_ptr<Instruction> &instruction, int numberOfOps);
    [[nodiscard]] DiagnosticPtr reportCantHaveTwoMemoryOperands(const std::shared_ptr<Instruction> &instruction);
    [[nodiscard]] DiagnosticPtr reportDestinationOperandCantBeImmediate(const std::shared_ptr<Instruction> &instruction);
    [[nodiscard]] DiagnosticPtr reportImmediateOperandTooBig(const std::shared_ptr<Instruction> &instruction, int firstOpSize, int immediateOpSize);
    [[nodiscard]] DiagnosticPtr reportOperandsHaveDifferentSize(const std::shared_ptr<Instruction> &instruction, int firstOpSize, int secondOpSize);

    // RecordDir errors
    [[nodiscard]] DiagnosticPtr reportRecordWidthTooBig(const std::shared_ptr<RecordDir> &recordDir, int32_t width);

    // RecordField errors
    [[nodiscard]] DiagnosticPtr reportRecordFieldWidthMustBePositive(const std::shared_ptr<RecordField> &recordField, int64_t width);
    [[nodiscard]] DiagnosticPtr reportRecordFieldWidthTooBig(const std::shared_ptr<RecordField> &recordField, int64_t width);

    [[nodiscard]] DiagnosticPtr reportExpressionMustBeMemoryOrRegisterOperand(const ExpressionPtr &operand);
    [[nodiscard]] DiagnosticPtr reportExpressionMustHaveSize(const ExpressionPtr &operand);
    [[nodiscard]] DiagnosticPtr reportInvalidOperandSize(const ExpressionPtr &operand, const std::string &expectedSize, int actualSize);

    // Expression errors
    [[nodiscard]] DiagnosticPtr reportExpressionMustBeConstant(ExpressionPtr &expr);
    [[nodiscard]] DiagnosticPtr reportUndefinedSymbol(const Token &token, bool isDefinedLater);
    [[nodiscard]] DiagnosticPtr reportRegisterNotAllowed(const Token &reg);
    [[nodiscard]] DiagnosticPtr reportNumberTooLarge(const Token &number);
    [[nodiscard]] DiagnosticPtr reportStringTooLarge(const Token &string);
    [[nodiscard]] DiagnosticPtr reportUnaryOperatorIncorrectArgument(const std::shared_ptr<UnaryOperator> &node);

    [[nodiscard]] DiagnosticPtr reportDotOperatorIncorrectArgument(const std::shared_ptr<BinaryOperator> &node);
    [[nodiscard]] DiagnosticPtr reportDotOperatorSizeNotSpecified(const std::shared_ptr<BinaryOperator> &node);
    [[nodiscard]] DiagnosticPtr reportDotOperatorTypeNotStruct(const std::shared_ptr<BinaryOperator> &node, const std::string &actualType);
    [[nodiscard]] DiagnosticPtr reportDotOperatorFieldDoesntExist(const std::shared_ptr<BinaryOperator> &node, const std::string &strucName,
                                                                  const std::string &fieldName);

    [[nodiscard]] DiagnosticPtr reportPtrOperatorIncorrectArgument(const std::shared_ptr<BinaryOperator> &node);

    [[nodiscard]] DiagnosticPtr reportDivisionByZero(const std::shared_ptr<BinaryOperator> &node);
    [[nodiscard]] DiagnosticPtr reportInvalidScaleValue(const std::shared_ptr<BinaryOperator> &node);
    [[nodiscard]] DiagnosticPtr reportIncorrectIndexRegister(const std::shared_ptr<Leaf> &node);
    [[nodiscard]] DiagnosticPtr reportOtherBinaryOperatorIncorrectArgument(const std::shared_ptr<BinaryOperator> &node);
    [[nodiscard]] DiagnosticPtr reportCantHaveRegistersInExpression(const ExpressionPtr &node);
    [[nodiscard]] DiagnosticPtr reportCantAddVariables(const ExpressionPtr &node, bool implicit);
    [[nodiscard]] DiagnosticPtr reportMoreThanTwoRegistersAfterAdd(const ExpressionPtr &node, bool implicit);
    [[nodiscard]] DiagnosticPtr reportMoreThanOneScaleAfterAdd(const ExpressionPtr &node, bool implicit);
    [[nodiscard]] DiagnosticPtr reportTwoEsp(const ExpressionPtr &node, bool implicit);
    [[nodiscard]] DiagnosticPtr reportNon32bitRegister(const ExpressionPtr &node, bool implicit);
    [[nodiscard]] DiagnosticPtr reportBinaryMinusOperatorIncorrectArgument(const std::shared_ptr<BinaryOperator> &node);
    [[nodiscard]] DiagnosticPtr reportNonRegisterInSquareBrackets(const std::shared_ptr<BinaryOperator> &node);

    void warnTypeReturnsZero(const std::shared_ptr<UnaryOperator> &node);

    static void findRelocatableVariables(const ExpressionPtr &node, std::optional<Token> &firstVar, std::optional<Token> &secondVar);

    static void findInvalidExpressionCause(const ExpressionPtr &node, ExpressionPtr &errorNode);

    static std::string getSymbolType(const std::shared_ptr<Symbol> &symbol);

    std::string getOperandType(const ExpressionPtr &node);

    std::shared_ptr<ParseSession> parseSess;
    ASTPtr ast;

    int pass = 1;
    int expressionDepth = 0;
    int dataInitializerDepth = 0;

    uint32_t currentOffset = 0;
    ASTPtr currentLine;
    std::vector<ASTPtr> linesForSecondPass;

    static std::map<std::string, int> registerSizes;
    static std::map<int, std::string> sizeValueToStr;
    static std::map<std::string, int> sizeStrToValue;
    static std::map<std::string, std::string> dataDirectiveToSizeStr;
    static std::unordered_set<std::string> builtinTypes;
    static std::unordered_set<std::string> dataDirectives;
};

// TODO: move this function somewhere else
inline std::optional<uint64_t> parseNumber(const std::string &input)
{
    if (input.empty()) {
        LOG_DETAILED_ERROR("Input string is empty!");
        return std::nullopt;
    }

    char suffix = static_cast<char>(tolower(input.back()));
    int base = 10;
    std::string numberPart = input;

    switch (suffix) {
    case 'h':
        base = 16;
        break;
    case 'b':
    case 'y':
        base = 2;
        break;
    case 'o':
    case 'q':
        base = 8;
        break;
    case 'd':
    case 't':
        base = 10;
        break;
    default:
        break;
    }

    // If there's a valid suffix, remove it from the number part
    if (suffix == 'h' || suffix == 'b' || suffix == 'y' || suffix == 'o' || suffix == 'q' || suffix == 'd' || suffix == 't') {
        numberPart = input.substr(0, input.size() - 1);
    }

    // Convert the string to a number
    char *end = nullptr;
    errno = 0;
    uint64_t result = std::strtoull(numberPart.c_str(), &end, base);

    if (errno == ERANGE) {
        // overflow occured
        return std::nullopt;
    } else if (errno != 0) {
        return std::nullopt;
    }

    // Check for conversion errors
    if (*end != '\0') {
        LOG_DETAILED_ERROR("Invalid number format!");
        return std::nullopt;
    }

    return result;
}
File semantic_analyzer_errors_reporting.cpp:

#include "semantic_analyzer.h"
#include "log.h"
#include "token.h"

// TODO: think more about naming types for users
// dont rely on this in code
std::string SemanticAnalyzer::getOperandType(const ExpressionPtr &node)
{
    std::shared_ptr<Leaf> leaf;
    if ((leaf = std::dynamic_pointer_cast<Leaf>(node))) {
        switch (leaf->token.type) {
        case TokenType::Identifier: {
            if (!parseSess->symbolTable->findSymbol(leaf->token)) {
                return "undefined identifier";
            }
            std::shared_ptr<Symbol> symbol = parseSess->symbolTable->findSymbol(leaf->token);
            if (auto dataVariableSymbol = std::dynamic_pointer_cast<DataVariableSymbol>(symbol)) {
                return "data variable";
            } else if (auto equVariableSymbol = std::dynamic_pointer_cast<EquVariableSymbol>(symbol)) {
                return "`EQU` variable";
            } else if (auto equalVariableSymbol = std::dynamic_pointer_cast<EqualVariableSymbol>(symbol)) {
                return "`=` variable";
            } else if (auto labelSymbol = std::dynamic_pointer_cast<LabelSymbol>(symbol)) {
                return "label variable";
            } else if (auto structSymbol = std::dynamic_pointer_cast<StructSymbol>(symbol)) {
                return "`STRUC` symbol";
            } else if (auto procSymbol = std::dynamic_pointer_cast<ProcSymbol>(symbol)) {
                return "`PROC` variable";
            } else if (auto recordSymbol = std::dynamic_pointer_cast<RecordSymbol>(symbol)) {
                return "`RECORD` symbol";
            } else if (auto recordFieldSymbol = std::dynamic_pointer_cast<RecordFieldSymbol>(symbol)) {
                return "`RECORD` field symbol";
            }
        }
        case TokenType::Number:
        case TokenType::StringLiteral:
            return "constant";
        case TokenType::Type:
            return "builtin type";
        default:
            return "error";
        }
    }

    if (node->constantValue) {
        return "constant expression";
    }
    if (node->type == OperandType::RegisterOperand) {
        return "register";
    }
    if (node->type == OperandType::ImmediateOperand) {
        return "immediate operand"; // = relocatable constant expression
    }
    if (node->type == OperandType::UnfinishedMemoryOperand) {
        return "invalid expression"; // shouldn't have to display this to user, should catch it earlier!
        // return "address expression without []";
    }
    if (node->registers.empty()) {
        return "address expression";
    } else {
        return "address expression with modificators";
    }
}

std::string SemanticAnalyzer::getSymbolType(const std::shared_ptr<Symbol> &symbol)
{
    if (auto dataVariableSymbol = std::dynamic_pointer_cast<DataVariableSymbol>(symbol)) {
        return "Data Variable";
    } else if (auto equVariableSymbol = std::dynamic_pointer_cast<EquVariableSymbol>(symbol)) {
        return "EQU Variable";
    } else if (auto equalVariableSymbol = std::dynamic_pointer_cast<EqualVariableSymbol>(symbol)) {
        return "`=` Variable";
    } else if (auto labelSymbol = std::dynamic_pointer_cast<LabelSymbol>(symbol)) {
        return "Label Variable";
    } else if (auto structSymbol = std::dynamic_pointer_cast<StructSymbol>(symbol)) {
        return "STRUC";
    } else if (auto procSymbol = std::dynamic_pointer_cast<ProcSymbol>(symbol)) {
        return "PROC";
    } else if (auto recordSymbol = std::dynamic_pointer_cast<RecordSymbol>(symbol)) {
        return "RECORD";
    } else if (auto recordFieldSymbol = std::dynamic_pointer_cast<RecordFieldSymbol>(symbol)) {
        return "RECORD Field";
    }
    return "unknown";
}

// DataItem errors
DiagnosticPtr SemanticAnalyzer::reportInvalidDataType(const std::shared_ptr<DataItem> &dataItem)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::INVALID_DATA_TYPE, dataItem->dataTypeToken.lexeme);
    Token dataTypeToken = dataItem->dataTypeToken;
    std::shared_ptr<Symbol> dataTypeSymbol = parseSess->symbolTable->findSymbol(dataTypeToken);
    if (!dataTypeSymbol) {
        LOG_DETAILED_ERROR("this shouldn't be null");
        return parseSess->dcx->getLastDiagnostic();
    }
    diag.addPrimaryLabel(dataTypeToken.span, fmt::format("Expected a `STRUC` or `RECORD` type, but this is a `{}`", getSymbolType(dataTypeSymbol)));
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

// InitValue errors
DiagnosticPtr SemanticAnalyzer::reportExpectedStrucOrRecordDataInitializer(const std::shared_ptr<InitValue> &initValue,
                                                                           const Token &expectedTypeToken)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::INVALID_DATA_INITIALIZER);
    std::shared_ptr<Symbol> expectedTypeSymbol = parseSess->symbolTable->findSymbol(expectedTypeToken);
    if (std::dynamic_pointer_cast<StructSymbol>(expectedTypeSymbol)) {
        diag.addPrimaryLabel(getInitValueSpan(initValue), fmt::format("expected a `STRUC` data initializer"));
    } else if (std::dynamic_pointer_cast<RecordSymbol>(expectedTypeSymbol)) {
        diag.addPrimaryLabel(getInitValueSpan(initValue), fmt::format("expected a `RECORD` data initializer"));
    } else {
        LOG_DETAILED_ERROR("should be only record or struc expected type");
        return parseSess->dcx->getLastDiagnostic();
    }
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

DiagnosticPtr SemanticAnalyzer::reportExpectedSingleItemDataInitializer(const std::shared_ptr<InitValue> &initValue,
                                                                        const Token & /*expectedTypeToken*/)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::INVALID_DATA_INITIALIZER);
    diag.addPrimaryLabel(getInitValueSpan(initValue), fmt::format("expected a single item data initializer"));
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

DiagnosticPtr SemanticAnalyzer::reportTooManyInitialValuesForRecord(const std::shared_ptr<InitValue> &initValue,
                                                                    const std::shared_ptr<RecordSymbol> &recordSymbol)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::TOO_MANY_INITIAL_VALUES_FOR_RECORD);
    diag.addPrimaryLabel(getInitValueSpan(initValue), fmt::format("expected `{}` initial values or less", recordSymbol->fields.size()));
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

DiagnosticPtr SemanticAnalyzer::reportTooManyInitialValuesForStruc(const std::shared_ptr<InitValue> &initValue,
                                                                   const std::shared_ptr<StructSymbol> &structSymbol)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::TOO_MANY_INITIAL_VALUES_FOR_STRUC);
    diag.addPrimaryLabel(getInitValueSpan(initValue), fmt::format("expected `{}` initial values or less", structSymbol->structDir->fields.size()));
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

// Instruction errors

DiagnosticPtr SemanticAnalyzer::reportInvalidNumberOfOperands(const std::shared_ptr<Instruction> &instruction, int numberOfOps)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::INVALID_NUMBER_OF_OPERANDS);
    Token mnemonicToken = instruction->mnemonicToken.value();
    diag.addPrimaryLabel(mnemonicToken.span, fmt::format("`{}` instruction takes {} operands", stringToUpper(mnemonicToken.lexeme), numberOfOps));
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

DiagnosticPtr SemanticAnalyzer::reportCantHaveTwoMemoryOperands(const std::shared_ptr<Instruction> &instruction)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::CANT_HAVE_TWO_MEMORY_OPERANDS);
    Token mnemonicToken = instruction->mnemonicToken.value();
    diag.addPrimaryLabel(mnemonicToken.span, "");
    diag.addSecondaryLabel(getExpressionSpan(instruction->operands[0]), "this is a memory operand");
    diag.addSecondaryLabel(getExpressionSpan(instruction->operands[1]), "this is a memory operand");
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

DiagnosticPtr SemanticAnalyzer::reportDestinationOperandCantBeImmediate(const std::shared_ptr<Instruction> &instruction)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::DESTINATION_OPERAND_CANT_BE_IMMEDIATE);
    diag.addPrimaryLabel(getExpressionSpan(instruction->operands[0]), "");
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

DiagnosticPtr SemanticAnalyzer::reportImmediateOperandTooBig(const std::shared_ptr<Instruction> &instruction, int firstOpSize, int immediateOpSize)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::IMMEDIATE_OPERAND_TOO_BIG);
    Token mnemonicToken = instruction->mnemonicToken.value();
    diag.addPrimaryLabel(mnemonicToken.span, "");

    diag.addSecondaryLabel(getExpressionSpan(instruction->operands[0]), fmt::format("this operand has size `{}`", firstOpSize));
    diag.addSecondaryLabel(
        getExpressionSpan(instruction->operands[1]),
        fmt::format("immediate operand has value `{}` and needs `{}` bytes", instruction->operands[1]->constantValue.value(), immediateOpSize));
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

DiagnosticPtr SemanticAnalyzer::reportOperandsHaveDifferentSize(const std::shared_ptr<Instruction> &instruction, int firstOpSize, int secondOpSize)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::OPERANDS_HAVE_DIFFERENT_SIZE);
    Token mnemonicToken = instruction->mnemonicToken.value();
    diag.addPrimaryLabel(mnemonicToken.span, "");

    diag.addSecondaryLabel(getExpressionSpan(instruction->operands[0]), fmt::format("this operand has size `{}`", firstOpSize));
    diag.addSecondaryLabel(getExpressionSpan(instruction->operands[1]), fmt::format("this operand has size `{}`", secondOpSize));

    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

DiagnosticPtr SemanticAnalyzer::reportExpressionMustBeMemoryOrRegisterOperand(const ExpressionPtr &operand)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::EXPRESSION_MUST_BE_MEMORY_OR_REGISTER_OPERAND);
    diag.addPrimaryLabel(getExpressionSpan(operand), fmt::format("this has type `{}`", getOperandType(operand)));
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

DiagnosticPtr SemanticAnalyzer::reportExpressionMustHaveSize(const ExpressionPtr &operand)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::EXPRESSION_MUST_HAVE_SIZE);
    diag.addPrimaryLabel(getExpressionSpan(operand), "");
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

DiagnosticPtr SemanticAnalyzer::reportInvalidOperandSize(const ExpressionPtr &operand, const std::string &expectedSize, int actualSize)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::INVALID_OPERAND_SIZE);
    diag.addPrimaryLabel(getExpressionSpan(operand), fmt::format("this operand must have size `{}`, but it has size `{}`", expectedSize, actualSize));
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

// RecordDir errors
DiagnosticPtr SemanticAnalyzer::reportRecordWidthTooBig(const std::shared_ptr<RecordDir> &recordDir, int32_t width)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::RECORD_WIDTH_TOO_BIG);
    Token recordIdToken = recordDir->idToken;
    diag.addPrimaryLabel(recordIdToken.span, fmt::format("this `RECORD` has total width `{}`", width));
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

// RecordField errors
DiagnosticPtr SemanticAnalyzer::reportRecordFieldWidthMustBePositive(const std::shared_ptr<RecordField> &recordField, int64_t width)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::RECORD_FIELD_WIDTH_MUST_BE_POSITIVE);
    diag.addPrimaryLabel(getExpressionSpan(recordField->width), fmt::format("this evaluates to `{}`", width));
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

DiagnosticPtr SemanticAnalyzer::reportRecordFieldWidthTooBig(const std::shared_ptr<RecordField> &recordField, int64_t width)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::RECORD_FIELD_TOO_BIG);
    diag.addPrimaryLabel(getExpressionSpan(recordField->width), fmt::format("this evaluates to `{}`", width));
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

// Expression errors
DiagnosticPtr SemanticAnalyzer::reportExpressionMustBeConstant(ExpressionPtr &expr)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::EXPRESSION_MUST_BE_CONSTANT);
    diag.addPrimaryLabel(getExpressionSpan(expr), "");
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

DiagnosticPtr SemanticAnalyzer::reportUndefinedSymbol(const Token &token, bool isDefinedLater)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::UNDEFINED_SYMBOL, token.lexeme);
    diag.addPrimaryLabel(token.span, "");
    if (isDefinedLater) {
        std::shared_ptr<Symbol> symbol = parseSess->symbolTable->findSymbol(token);
        if (!symbol) {
            LOG_DETAILED_ERROR("Defined later symbol not found");
            return parseSess->dcx->getLastDiagnostic();
        }
        diag.addSecondaryLabel(symbol->token.span, "this symbol is defined later, but forward references aren't allowed");
    }
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

DiagnosticPtr SemanticAnalyzer::reportRegisterNotAllowed(const Token &reg)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::REGISTER_NOT_ALLOWED);
    diag.addPrimaryLabel(reg.span, "");
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

DiagnosticPtr SemanticAnalyzer::reportNumberTooLarge(const Token &number)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::CONSTANT_TOO_LARGE);
    diag.addPrimaryLabel(number.span, "");
    diag.addNoteMessage("maximum allowed size is 32 bits");
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

DiagnosticPtr SemanticAnalyzer::reportStringTooLarge(const Token &string)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::CONSTANT_TOO_LARGE);
    diag.addPrimaryLabel(string.span, "");
    diag.addNoteMessage("maximum allowed size is 32 bits");
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

DiagnosticPtr SemanticAnalyzer::reportUnaryOperatorIncorrectArgument(const std::shared_ptr<UnaryOperator> &node)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::UNARY_OPERATOR_INCORRECT_ARGUMENT, stringToUpper(node->op.lexeme));

    std::string op = stringToUpper(node->op.lexeme);
    std::string expectedStr;
    if (op == "LENGTH" || op == "LENGTHOF" || op == "SIZE" || op == "SIZEOF") {
        expectedStr = "expected `data label`"; // TODO: change this?
    } else if (op == "WIDTH" || op == "MASK") {
        expectedStr = "expected `RECORD symbol` or `RECORD field symbol";
    } else if (op == "OFFSET") {
        expectedStr = "expected `address expression`";
    } else if (op == "TYPE") {
        expectedStr = "expected valid expression";
    } else if (op == "+" || op == "-") {
        expectedStr = "expected `constant expression`";
    }
    auto operand = node->operand;
    diag.addPrimaryLabel(node->op.span, "");
    diag.addSecondaryLabel(getExpressionSpan(operand), fmt::format("{}, found `{}`", expectedStr, getOperandType(operand)));

    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

// Dot Operator
DiagnosticPtr SemanticAnalyzer::reportDotOperatorIncorrectArgument(const std::shared_ptr<BinaryOperator> &node)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::DOT_OPERATOR_INCORRECT_ARGUMENT);

    auto left = node->left;
    auto right = node->right;

    diag.addPrimaryLabel(node->op.span, "");

    std::shared_ptr<Leaf> leaf;
    if (left->constantValue || left->type == OperandType::RegisterOperand) {
        diag.addSecondaryLabel(getExpressionSpan(left), fmt::format("expected `address expression`, found `{}`", getOperandType(left)));
    }
    if (!(leaf = std::dynamic_pointer_cast<Leaf>(right)) || leaf->token.type != TokenType::Identifier) {
        diag.addSecondaryLabel(getExpressionSpan(right), fmt::format("expected `identifier`, found `{}`", getOperandType(right)));
    }

    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

DiagnosticPtr SemanticAnalyzer::reportDotOperatorSizeNotSpecified(const std::shared_ptr<BinaryOperator> &node)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::DOT_OPERATOR_INCORRECT_ARGUMENT);
    diag.addPrimaryLabel(node->op.span, "");
    diag.addSecondaryLabel(getExpressionSpan(node->left), "this expression doesn't have a type");
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

DiagnosticPtr SemanticAnalyzer::reportDotOperatorTypeNotStruct(const std::shared_ptr<BinaryOperator> &node, const std::string &actualType)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::DOT_OPERATOR_INCORRECT_ARGUMENT);
    diag.addPrimaryLabel(node->op.span, "");
    diag.addSecondaryLabel(getExpressionSpan(node->left),
                           fmt::format("this expression must have `STRUC` type, but it has a builtin type `{}`", actualType));
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

DiagnosticPtr SemanticAnalyzer::reportDotOperatorFieldDoesntExist(const std::shared_ptr<BinaryOperator> &node, const std::string &strucName,
                                                                  const std::string &fieldName)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::DOT_OPERATOR_FIELD_DOESNT_EXIST, strucName, fieldName);
    diag.addPrimaryLabel(getExpressionSpan(node->right), "");
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

// PTR operator
DiagnosticPtr SemanticAnalyzer::reportPtrOperatorIncorrectArgument(const std::shared_ptr<BinaryOperator> &node)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::PTR_OPERATOR_INCORRECT_ARGUMENT);

    auto left = node->left;
    auto right = node->right;

    diag.addPrimaryLabel(node->op.span, "");

    std::shared_ptr<Leaf> leaf;
    // CRITICAL TODO: left can also be identifier, if it's a type symbol
    if (!(leaf = std::dynamic_pointer_cast<Leaf>(left)) || leaf->token.type != TokenType::Type /* !=TokenType::Identifier */) {
        diag.addSecondaryLabel(getExpressionSpan(left), fmt::format("expected `type`, found `{}`", getOperandType(left)));
    }
    if (right->type == OperandType::UnfinishedMemoryOperand || right->type == OperandType::RegisterOperand) {
        // Change that we can expect also constants?
        diag.addSecondaryLabel(getExpressionSpan(right), fmt::format("expected `address expression`, found `{}`", getOperandType(right)));
    }

    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

DiagnosticPtr SemanticAnalyzer::reportDivisionByZero(const std::shared_ptr<BinaryOperator> &node)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::DIVISION_BY_ZERO_IN_EXPRESSION);

    auto right = node->right;

    diag.addPrimaryLabel(node->op.span, "");

    diag.addSecondaryLabel(getExpressionSpan(right), "this evaluates to `0`");

    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

DiagnosticPtr SemanticAnalyzer::reportInvalidScaleValue(const std::shared_ptr<BinaryOperator> &node)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::INVALID_SCALE_VALUE);

    auto left = node->left;
    auto right = node->right;

    if (left->constantValue) {
        diag.addPrimaryLabel(getExpressionSpan(left), fmt::format("this evaluates to `{}`", left->constantValue.value()));
    } else {
        diag.addPrimaryLabel(getExpressionSpan(right), fmt::format("this evaluates to `{}`", right->constantValue.value()));
    }

    diag.addNoteMessage("scale can only be {1, 2, 4, 8}");

    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

DiagnosticPtr SemanticAnalyzer::reportIncorrectIndexRegister(const std::shared_ptr<Leaf> &node)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::INCORRECT_INDEX_REGISTER);
    diag.addPrimaryLabel(node->token.span, "");
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

DiagnosticPtr SemanticAnalyzer::reportOtherBinaryOperatorIncorrectArgument(const std::shared_ptr<BinaryOperator> &node)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::OTHER_BINARY_OPERATOR_INCORRECT_ARGUMENT, node->op.lexeme);

    auto left = node->left;
    auto right = node->right;

    if (left->type == OperandType::RegisterOperand && node->op.lexeme == "*") {
        diag.addPrimaryLabel(node->op.span, "");
        diag.addSecondaryLabel(getExpressionSpan(right), fmt::format("expected `constant expression`, found `{}`", getOperandType(right)));
    } else if (right->type == OperandType::RegisterOperand && node->op.lexeme == "*") {
        diag.addPrimaryLabel(node->op.span, "");
        diag.addSecondaryLabel(getExpressionSpan(left), fmt::format("expected `constant expression`, found `{}`", getOperandType(left)));
    } else {
        if (node->op.lexeme == "*") {
            diag.addPrimaryLabel(node->op.span, "can only multiply constant expressions or a register by the scale");
        } else {
            diag.addPrimaryLabel(node->op.span, fmt::format("operator `{}` supports only constant expressions", node->op.lexeme));
        }

        diag.addSecondaryLabel(getExpressionSpan(left), fmt::format("help: this has type `{}`", getOperandType(left)));
        diag.addSecondaryLabel(getExpressionSpan(right), fmt::format("help: this has type `{}`", getOperandType(right)));
    }

    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

// called when there's unfinished memory operand that needs to be finished
DiagnosticPtr SemanticAnalyzer::reportCantHaveRegistersInExpression(const ExpressionPtr &node)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::CANT_HAVE_REGISTERS_IN_EXPRESSION);

    // find first thing that lead to UnfinishedMemoryOperand and print it
    ExpressionPtr errorNode;
    findInvalidExpressionCause(node, errorNode);

    if (!errorNode) {
        LOG_DETAILED_ERROR("Can't find invalid expression cause");
    } else {
        if (auto binaryOp = std::dynamic_pointer_cast<BinaryOperator>(errorNode)) {
            diag.addPrimaryLabel(getExpressionSpan(binaryOp), "");

        } else if (auto implicitPlus = std::dynamic_pointer_cast<ImplicitPlusOperator>(errorNode)) {
            diag.addPrimaryLabel(getExpressionSpan(implicitPlus), "");
        }
    }

    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

void SemanticAnalyzer::findInvalidExpressionCause(const ExpressionPtr &node, ExpressionPtr &errorNode)
{
    if (node->diagnostic) {
        return;
    }
    if (node->type == OperandType::UnfinishedMemoryOperand) {
        errorNode = node;
    }
    if (auto binaryOp = std::dynamic_pointer_cast<BinaryOperator>(node)) {
        if (binaryOp->left->type == OperandType::UnfinishedMemoryOperand) {
            errorNode = binaryOp;
            findInvalidExpressionCause(binaryOp->left, errorNode);
        }
        if (binaryOp->right->type == OperandType::UnfinishedMemoryOperand) {
            errorNode = binaryOp;
            findInvalidExpressionCause(binaryOp->right, errorNode);
        }
    } else if (auto unaryOp = std::dynamic_pointer_cast<UnaryOperator>(node)) {
        findInvalidExpressionCause(unaryOp->operand, errorNode);
    } else if (auto brackets = std::dynamic_pointer_cast<Brackets>(node)) {
        findInvalidExpressionCause(brackets->operand, errorNode);
    } else if (auto squareBrackets = std::dynamic_pointer_cast<SquareBrackets>(node)) {
        findInvalidExpressionCause(squareBrackets->operand, errorNode);
    } else if (auto implicitPlus = std::dynamic_pointer_cast<ImplicitPlusOperator>(node)) {
        if (implicitPlus->left->type == OperandType::UnfinishedMemoryOperand) {
            errorNode = implicitPlus;
            findInvalidExpressionCause(implicitPlus->left, errorNode);
        }
        if (implicitPlus->right->type == OperandType::UnfinishedMemoryOperand) {
            errorNode = implicitPlus;
            findInvalidExpressionCause(implicitPlus->right, errorNode);
        }
    } else if (auto leaf = std::dynamic_pointer_cast<Leaf>(node)) {
        return;
    } else {
        LOG_DETAILED_ERROR("Unknown Expression Node!\n");
        return;
    }
}

DiagnosticPtr SemanticAnalyzer::reportCantAddVariables(const ExpressionPtr &node, bool implicit)
{
    std::optional<Token> firstVar;
    std::optional<Token> secondVar;
    findRelocatableVariables(node, firstVar, secondVar);
    if (!firstVar || !secondVar) {
        LOG_DETAILED_ERROR("Can't find the 2 relocatable variables!\n");
        return parseSess->dcx->getLastDiagnostic();
    }

    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::CANT_ADD_VARIABLES, implicit ? "implicitly" : "");

    if (implicit) {
        auto implicitOp = std::dynamic_pointer_cast<ImplicitPlusOperator>(node);
        // TODO: what to underline when [var][var]
        diag.addPrimaryLabel(firstVar.value().span, "first variable");
        diag.addSecondaryLabel(secondVar.value().span, "second variable");
    } else {
        auto binaryOp = std::dynamic_pointer_cast<BinaryOperator>(node);
        diag.addPrimaryLabel(binaryOp->op.span, "");
        diag.addSecondaryLabel(firstVar.value().span, "first variable");
        diag.addSecondaryLabel(secondVar.value().span, "second variable");
    }

    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

void SemanticAnalyzer::findRelocatableVariables(const ExpressionPtr &node, std::optional<Token> &firstVar, std::optional<Token> &secondVar)
{
    if (node->diagnostic) {
        return;
    }
    if (auto binaryOp = std::dynamic_pointer_cast<BinaryOperator>(node)) {
        if (binaryOp->op.lexeme == ".") {
            if (binaryOp->left->isRelocatable) {
                findRelocatableVariables(binaryOp->left, firstVar, secondVar);
                return;
            }
        }
        if (binaryOp->left->isRelocatable) {
            findRelocatableVariables(binaryOp->left, firstVar, secondVar);
        }
        if (binaryOp->right->isRelocatable) {
            findRelocatableVariables(binaryOp->right, firstVar, secondVar);
        }
    } else if (auto unaryOp = std::dynamic_pointer_cast<UnaryOperator>(node)) {
        if (unaryOp->operand->isRelocatable) {
            findRelocatableVariables(unaryOp->operand, firstVar, secondVar);
        }
    } else if (auto brackets = std::dynamic_pointer_cast<Brackets>(node)) {
        if (brackets->operand->isRelocatable) {
            findRelocatableVariables(brackets->operand, firstVar, secondVar);
        }
    } else if (auto squareBrackets = std::dynamic_pointer_cast<SquareBrackets>(node)) {
        if (squareBrackets->operand->isRelocatable) {
            findRelocatableVariables(squareBrackets->operand, firstVar, secondVar);
        }
    } else if (auto implicitPlus = std::dynamic_pointer_cast<ImplicitPlusOperator>(node)) {
        if (implicitPlus->left->isRelocatable) {
            findRelocatableVariables(implicitPlus->left, firstVar, secondVar);
        }
        if (implicitPlus->right->isRelocatable) {
            findRelocatableVariables(implicitPlus->right, firstVar, secondVar);
        }
    } else if (auto leaf = std::dynamic_pointer_cast<Leaf>(node)) {
        if (!firstVar) {
            firstVar = leaf->token;
        } else if (!secondVar) {
            secondVar = leaf->token;
        }
    } else {
        LOG_DETAILED_ERROR("Unknown Expression Node!\n");
        return;
    }
}

DiagnosticPtr SemanticAnalyzer::reportMoreThanTwoRegistersAfterAdd(const ExpressionPtr &node, bool implicit)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::MORE_THAN_TWO_REGISTERS);

    if (implicit) {
        auto implicitOp = std::dynamic_pointer_cast<ImplicitPlusOperator>(node);
        // TODO: what to underline when [var][var]
        bool first = true;

        for (const auto &[reg, scale] : implicitOp->left->registers) {
            if (first) {
                diag.addPrimaryLabel(reg.span, "help: register");
                first = false;
                continue;
            }
            diag.addSecondaryLabel(reg.span, "help: register");
            first = false;
        }

        for (const auto &[reg, scale] : implicitOp->right->registers) {
            if (first) {
                diag.addPrimaryLabel(reg.span, "help: register");
                first = false;
                continue;
            }
            diag.addSecondaryLabel(reg.span, "help: register");
        }
    } else {
        auto binaryOp = std::dynamic_pointer_cast<BinaryOperator>(node);
        diag.addPrimaryLabel(binaryOp->op.span, ""); // write "this + resulted in having more than 2 registers?""
        for (const auto &[reg, scale] : binaryOp->left->registers) {
            diag.addSecondaryLabel(reg.span, "help: register");
        }

        for (const auto &[reg, scale] : binaryOp->right->registers) {
            diag.addSecondaryLabel(reg.span, "help: register");
        }
    }

    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

DiagnosticPtr SemanticAnalyzer::reportMoreThanOneScaleAfterAdd(const ExpressionPtr &node, bool implicit)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::MORE_THAN_ONE_SCALE);

    if (implicit) {
        auto implicitOp = std::dynamic_pointer_cast<ImplicitPlusOperator>(node);
        // TODO: what to underline when [var][var]
        bool first = true;

        for (const auto &[reg, scale] : implicitOp->left->registers) {
            if (first && scale) {
                diag.addPrimaryLabel(reg.span, "help: this register has a scale");
                first = false;
                continue;
            }
            if (scale) {
                diag.addSecondaryLabel(reg.span, "help: this register has a scale");
            }
        }

        for (const auto &[reg, scale] : implicitOp->right->registers) {
            if (first && scale) {
                diag.addPrimaryLabel(reg.span, "help: this register has a scale");
                first = false;
                continue;
            }
            if (scale) {
                diag.addSecondaryLabel(reg.span, "help: this register has a scale");
            }
        }
    } else {
        auto binaryOp = std::dynamic_pointer_cast<BinaryOperator>(node);
        diag.addPrimaryLabel(binaryOp->op.span, ""); // write "this + resulted in having more than 1 scale?""
        for (const auto &[reg, scale] : binaryOp->left->registers) {
            if (scale) {
                diag.addSecondaryLabel(reg.span, "help: this register has a scale");
            }
        }

        for (const auto &[reg, scale] : binaryOp->right->registers) {
            if (scale) {
                diag.addSecondaryLabel(reg.span, "help: this register has a scale");
            }
        }
    }

    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

DiagnosticPtr SemanticAnalyzer::reportTwoEsp(const ExpressionPtr &node, bool implicit)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::TWO_ESP_REGISTERS);

    if (implicit) {
        auto implicitOp = std::dynamic_pointer_cast<ImplicitPlusOperator>(node);
        bool first = true;

        for (const auto &[reg, scale] : implicitOp->left->registers) {
            if (first && stringToUpper(reg.lexeme) == "ESP") {
                diag.addPrimaryLabel(reg.span, "help: this is a ESP register");
                first = false;
                continue;
            }
            if (stringToUpper(reg.lexeme) == "ESP") {
                diag.addSecondaryLabel(reg.span, "help: this is a ESP register");
            }
        }

        for (const auto &[reg, scale] : implicitOp->right->registers) {
            if (first && stringToUpper(reg.lexeme) == "ESP") {
                diag.addPrimaryLabel(reg.span, "help: this is a ESP register");
                first = false;
                continue;
            }
            if (stringToUpper(reg.lexeme) == "ESP") {
                diag.addSecondaryLabel(reg.span, "help: this is a ESP register");
            }
        }
    } else {
        auto binaryOp = std::dynamic_pointer_cast<BinaryOperator>(node);
        diag.addPrimaryLabel(binaryOp->op.span, "");
        for (const auto &[reg, scale] : binaryOp->left->registers) {
            if (stringToUpper(reg.lexeme) == "ESP") {
                diag.addSecondaryLabel(reg.span, "help: this is a ESP register");
            }
        }

        for (const auto &[reg, scale] : binaryOp->right->registers) {
            if (stringToUpper(reg.lexeme) == "ESP") {
                diag.addSecondaryLabel(reg.span, "help: this is a ESP register");
            }
        }
    }

    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

DiagnosticPtr SemanticAnalyzer::reportNon32bitRegister(const ExpressionPtr &node, bool implicit)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::NON_32BIT_REGISTER);

    if (auto reg = std::dynamic_pointer_cast<Leaf>(node)) {
        int size = registerSizes[stringToUpper(reg->token.lexeme)];
        diag.addPrimaryLabel(reg->token.span, fmt::format("this is a {} byte register", size));
        parseSess->dcx->addDiagnostic(diag);
        return parseSess->dcx->getLastDiagnostic();
    }

    if (implicit) {
        auto implicitOp = std::dynamic_pointer_cast<ImplicitPlusOperator>(node);
        bool first = true;

        for (const auto &[reg, scale] : implicitOp->left->registers) {
            int size = registerSizes[stringToUpper(reg.lexeme)];
            if (first && size != 4) {
                diag.addSecondaryLabel(reg.span, fmt::format("help: this is a {} byte register", size));
                first = false;
                continue;
            }
            if (size != 4) {
                diag.addSecondaryLabel(reg.span, fmt::format("help: this is a {} byte register", size));
            }
        }

        for (const auto &[reg, scale] : implicitOp->right->registers) {
            int size = registerSizes[stringToUpper(reg.lexeme)];
            if (first && size != 4) {
                diag.addSecondaryLabel(reg.span, fmt::format("help: this is a {} byte register", size));
                first = false;
                continue;
            }
            if (size != 4) {
                diag.addSecondaryLabel(reg.span, fmt::format("help: this is a {} byte register", size));
            }
        }
    } else {
        auto binaryOp = std::dynamic_pointer_cast<BinaryOperator>(node);
        diag.addPrimaryLabel(binaryOp->op.span, "");
        for (const auto &[reg, scale] : binaryOp->left->registers) {
            int size = registerSizes[stringToUpper(reg.lexeme)];
            if (size != 4) {
                diag.addSecondaryLabel(reg.span, fmt::format("help: this is a {} byte register", size));
            }
        }

        for (const auto &[reg, scale] : binaryOp->right->registers) {
            int size = registerSizes[stringToUpper(reg.lexeme)];
            if (size != 4) {
                diag.addSecondaryLabel(reg.span, fmt::format("help: this is a {} byte register", size));
            }
        }
    }

    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

DiagnosticPtr SemanticAnalyzer::reportBinaryMinusOperatorIncorrectArgument(const std::shared_ptr<BinaryOperator> &node)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::BINARY_MINUS_OPERATOR_INCORRECT_ARGUMENT);

    auto left = node->left;
    auto right = node->right;

    diag.addPrimaryLabel(node->op.span, "can only subtract constant expressions or 2 address expressions");

    diag.addSecondaryLabel(getExpressionSpan(left), fmt::format("help: this has type `{}`", getOperandType(left)));
    diag.addSecondaryLabel(getExpressionSpan(right), fmt::format("help: this has type `{}`", getOperandType(right)));

    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

DiagnosticPtr SemanticAnalyzer::reportNonRegisterInSquareBrackets(const std::shared_ptr<BinaryOperator> &node)
{
    Diagnostic diag(Diagnostic::Level::Error, ErrorCode::NON_REGISTER_IN_SQUARE_BRACKETS);
    diag.addPrimaryLabel(getExpressionSpan(node), "");
    parseSess->dcx->addDiagnostic(diag);
    return parseSess->dcx->getLastDiagnostic();
}

void SemanticAnalyzer::warnTypeReturnsZero(const std::shared_ptr<UnaryOperator> &node)
{
    Diagnostic diag(Diagnostic::Level::Warning, ErrorCode::TYPE_RETURNS_ZERO);
    diag.addPrimaryLabel(node->op.span, "");
    diag.addSecondaryLabel(getExpressionSpan(node->operand), "this expression doesn't have a type");
    parseSess->dcx->addDiagnostic(diag);
}
File session.cpp:

#include "session.h"

#include <iostream>

ParseSession::ParseSession()
{
    sourceMap = std::make_shared<SourceMap>();
    // bool useColor = !isOutputRedirected(std::cout);
    bool useColor = true;
    auto emitter = std::make_shared<Emitter>(sourceMap, std::cout, useColor);
    dcx = std::make_shared<DiagCtxt>(emitter);
    symbolTable = std::make_shared<SymbolTable>();
}

File session.h:

#pragma once

#include <memory>
#include <string>
#include <filesystem>

#include "symbol_table.h"
#include "source_map.h"
#include "diag_ctxt.h"

class ParseSession {
public:
    ParseSession();

public:
    std::shared_ptr<DiagCtxt> dcx;
    std::shared_ptr<SourceMap> sourceMap;
    std::shared_ptr<SymbolTable> symbolTable;
};
File source_map.cpp:

#include "source_map.h"
#include "log.h"
#include "span.h"

#include <fstream>
#include <filesystem>

SourceFile::SourceFile(std::filesystem::path path, const std::string &src, std::size_t startPos)
    : path(std::move(path)), src(src), startPos(startPos), endPos(startPos + src.size())
{
    // Initialize lineStarts
    lineStarts.push_back(0);
    for (std::size_t i = 0; i < src.size(); ++i) {
        if (src[i] == '\n') {
            lineStarts.push_back(i + 1);
        }
    }
}

const std::filesystem::path &SourceFile::getPath() const { return path; }

const std::string &SourceFile::getSource() const { return src; }

std::size_t SourceFile::getStartPos() const { return startPos; }

std::size_t SourceFile::getEndPos() const { return endPos; }

std::size_t SourceFile::getLineNumber(std::size_t pos) const
{
    if (pos < startPos || pos >= endPos) {
        LOG_DETAILED_ERROR("Position out of range in getLineNumber");
        return 0;
    }
    std::size_t localPos = pos - startPos;
    auto it = std::upper_bound(lineStarts.begin(), lineStarts.end(), localPos);
    return static_cast<size_t>((it - lineStarts.begin())) - 1;
}

// lineNumber is zero based
std::string SourceFile::getLine(std::size_t lineNumber) const
{
    if (lineNumber >= lineStarts.size()) {
        LOG_DETAILED_ERROR("Line number out of range in getLine");
        return "";
    }
    std::size_t start = lineStarts[lineNumber];
    std::size_t end = 0;
    if (lineNumber + 1 < lineStarts.size()) {
        end = lineStarts[lineNumber + 1];
    } else {
        end = src.size();
    }

    // Exclude the newline character at the end if present
    if (end > start && src[end - 1] == '\n') {
        end--;
    }
    return src.substr(start, end - start);
}

// lineNumber is zero based
std::size_t SourceFile::getLineStart(std::size_t lineNumber) const
{
    if (lineNumber >= lineStarts.size()) {
        LOG_DETAILED_ERROR("Line number out of range in getLineStart");
        return 0;
    }
    return lineStarts[lineNumber];
}

std::size_t SourceFile::countCodePoints(const std::string &str, std::size_t startByte, std::size_t endByte)
{
    std::size_t codePointCount = 0;
    std::size_t i = startByte;
    while (i < endByte) {
        auto c = static_cast<unsigned char>(str[i]);
        std::size_t charSize = 1;
        if ((c & 0x80U) == 0x00) {
            charSize = 1; // ASCII character
        } else if ((c & 0xE0U) == 0xC0) {
            charSize = 2; // 2-byte sequence
        } else if ((c & 0xF0U) == 0xE0) {
            charSize = 3; // 3-byte sequence
        } else if ((c & 0xF8U) == 0xF0) {
            charSize = 4; // 4-byte sequence
        } else {
            // Invalid UTF-8 start byte
            LOG_DETAILED_ERROR("Invalid UTF-8 encoding in countCodePoints");
            charSize = 1;
        }

        // Move to the next character
        i += charSize;
        codePointCount++;
    }
    return codePointCount;
}

std::size_t SourceFile::getColumnNumber(std::size_t pos) const
{
    std::size_t lineNumber = getLineNumber(pos);
    std::size_t lineStartPos = lineStarts[lineNumber];
    std::size_t localPos = pos - startPos;

    // Count code points between lineStartPos and localPos
    return countCodePoints(src, lineStartPos, localPos);
}

std::size_t SourceFile::getColumnPosition(std::size_t pos) const
{
    std::size_t lineNumber = getLineNumber(pos);
    std::size_t lineStartPos = lineStarts[lineNumber];
    std::size_t localPos = pos - startPos;

    return localPos - lineStartPos;
}

std::shared_ptr<SourceFile> SourceMap::newSourceFile(const std::filesystem::path &path, const std::string &src)
{
    std::size_t startPos = 0;
    if (!files.empty()) {
        startPos = files.back()->getEndPos();
    }
    auto file = std::make_shared<SourceFile>(path, src, startPos);
    files.push_back(file);
    return file;
}

std::shared_ptr<SourceFile> SourceMap::loadFile(const std::filesystem::path &path)
{
    auto existingFile = getSourceFile(path);
    if (existingFile) {
        return existingFile;
    }

    std::ifstream file(path);
    if (!file.is_open()) {
        return nullptr;
    }

    std::stringstream buffer;
    buffer << file.rdbuf();
    std::string content = buffer.str();
    // TODO: remove this hack to handle EndOfFile drawing
    content += "\n";

    return newSourceFile(path, content);
}

std::shared_ptr<SourceFile> SourceMap::lookupSourceFile(std::size_t pos) const
{
    for (const auto &file : files) {
        if (file->getStartPos() <= pos && pos < file->getEndPos()) {
            return file;
        }
    }
    return nullptr;
}

std::shared_ptr<SourceFile> SourceMap::getSourceFile(const std::filesystem::path &path) const
{
    for (const auto &file : files) {
        if (file->getPath() == path) {
            return file;
        }
    }
    return nullptr;
}

std::pair<std::size_t, std::size_t> SourceMap::lookupLineColumn(std::size_t pos) const
{
    auto file = lookupSourceFile(pos);
    if (file) {
        std::size_t lineNumber = file->getLineNumber(pos);
        std::size_t columnNumber = file->getColumnNumber(pos);
        return {lineNumber + 1, columnNumber + 1}; // Lines and columns are 1-based
    } else {
        return {0, 0};
    }
}

void SourceMap::spanToLocation(const Span &span, std::filesystem::path &outPath, std::size_t &outLine,
                               std::size_t &outColumn) const
{
    // check if span corresponds to EndOfFile
    // if (files->())
    auto file = lookupSourceFile(span.lo);
    if (file) {
        outPath = file->getPath();
        outLine = file->getLineNumber(span.lo);     // Zero-based
        outColumn = file->getColumnNumber(span.lo); // Zero-based
    } else {
        outPath.clear();
        outLine = 0;
        outColumn = 0;
    }
}

void SourceMap::spanToEndLocation(const Span &span, std::filesystem::path &outPath, std::size_t &outLine,
                                  std::size_t &outColumn) const
{
    auto file = lookupSourceFile(span.hi - 1);
    if (file) {
        outPath = file->getPath();
        outLine = file->getLineNumber(span.hi - 1);         // Zero-based
        outColumn = file->getColumnNumber(span.hi - 1) + 1; // Zero-based
    } else {
        outPath.clear();
        outLine = 0;
        outColumn = 0;
    }
}

void SourceMap::spanToStartPosition(const Span &span, std::filesystem::path &outPath, std::size_t &outLine,
                                    std::size_t &outColumn) const
{
    auto file = lookupSourceFile(span.lo);
    if (file) {
        outPath = file->getPath();
        outLine = file->getLineNumber(span.lo); // Zero-based
        outColumn = file->getColumnPosition(span.lo);
    } else {
        outPath.clear();
        outLine = 0;
        outColumn = 0;
    }
}

void SourceMap::spanToEndPosition(const Span &span, std::filesystem::path &outPath, std::size_t &outLine,
                                  std::size_t &outColumn) const
{
    auto file = lookupSourceFile(span.hi - 1);
    if (file) {
        outPath = file->getPath();
        outLine = file->getLineNumber(span.hi - 1); // Zero-based
        // (need to add one because in the span (4, 5) startLocation is column 4 but endLocation column should be 5)
        outColumn = file->getColumnPosition(span.hi - 1) + 1; // Zero-based
    } else {
        outPath.clear();
        outLine = 0;
        outColumn = 0;
    }
}

std::string SourceMap::spanToSnippet(const Span &span) const
{
    auto sourceFile = lookupSourceFile(span.lo);
    if (!sourceFile) {
        LOG_DETAILED_ERROR("Span does not belong to any source file");
        return "";
    }

    std::size_t start_pos = span.lo - sourceFile->getStartPos();
    std::size_t end_pos = span.hi - sourceFile->getStartPos();

    if (end_pos > sourceFile->getSource().size()) {
        LOG_DETAILED_ERROR("Span end position out of range");
        return "";
    }

    return sourceFile->getSource().substr(start_pos, end_pos - start_pos);
}
File source_map.h:

#pragma once

#include <unordered_map>
#include <filesystem>
#include "span.h"

class SourceFile {
public:
    SourceFile(std::filesystem::path path, const std::string &src, std::size_t startPos);

    const std::filesystem::path &getPath() const;
    const std::string &getSource() const;

    std::size_t getStartPos() const;
    std::size_t getEndPos() const;

    // Maps a byte position to a line number (zer based)
    std::size_t getLineNumber(std::size_t pos) const;

    std::string getLine(std::size_t lineNumber) const;

    // Maps a byte position to a column number within its line (zero based)
    std::size_t getColumnNumber(std::size_t pos) const;

    std::size_t getColumnPosition(std::size_t pos) const;

    std::size_t getLineStart(std::size_t lineNumber) const;

    static std::size_t countCodePoints(const std::string &str, std::size_t startByte, std::size_t endByte);

private:
    std::filesystem::path path;
    std::string src;                     // Source code content
    std::size_t startPos;                // Starting position in the global source map (including startPos)
    std::size_t endPos;                  // Ending position in the global source map (excluding endPos)
    std::vector<std::size_t> lineStarts; // Byte positions where each line starts
};

class SourceMap {
public:
    SourceMap() = default;

    std::shared_ptr<SourceFile> newSourceFile(const std::filesystem::path &path, const std::string &src);

    std::shared_ptr<SourceFile> loadFile(const std::filesystem::path &path);

    std::shared_ptr<SourceFile> lookupSourceFile(std::size_t pos) const;

    std::shared_ptr<SourceFile> getSourceFile(const std::filesystem::path &path) const;

    // Maps a global byte position to line and column (zero based)
    std::pair<std::size_t, std::size_t> lookupLineColumn(std::size_t pos) const;

    // Maps a span to file path, line, and column (zero based)
    void spanToLocation(const Span &span, std::filesystem::path &outPath, std::size_t &outLine,
                        std::size_t &outColumn) const;

    void spanToEndLocation(const Span &span, std::filesystem::path &outPath, std::size_t &outLine,
                           std::size_t &outColumn) const;

    // Column is returned as a byte offset, TODO: refactor?
    void spanToStartPosition(const Span &span, std::filesystem::path &outPath, std::size_t &outLine,
                             std::size_t &outColumn) const;

    void spanToEndPosition(const Span &span, std::filesystem::path &outPath, std::size_t &outLine,
                           std::size_t &outColumn) const;

    // Retrieves the source code snippet corresponding to a span
    std::string spanToSnippet(const Span &span) const;

private:
    std::vector<std::shared_ptr<SourceFile>> files;
};
File span.cpp:

#include "span.h"
#include "log.h"

void SyntaxContextData::pushMacro(const std::string &macroName) { macroStack.push_back(macroName); }

void SyntaxContextData::popMacro()
{
    if (!macroStack.empty()) {
        macroStack.pop_back();
    }
}

std::string SyntaxContextData::currentMacro() const { return macroStack.empty() ? "" : macroStack.back(); }

bool Span::contains(std::size_t pos) const { return lo <= pos && pos < hi; }

bool Span::overlaps(const Span &other) const { return lo < other.hi && other.lo < hi; }

Span Span::merge(const Span &first, const Span &second)
{
    const std::size_t new_lo = std::min(first.lo, second.lo);
    const std::size_t new_hi = std::max(first.hi, second.hi);

    std::shared_ptr<SyntaxContextData> new_context = first.context;

    if (first.context != second.context) {
        LOG_DETAILED_ERROR("Can't merge spans with different contexts!");
        return {0, 0, nullptr};
    }

    return {new_lo, new_hi, new_context};
}

bool Span::operator==(const Span &other) const { return lo == other.lo && hi == other.hi && context == other.context; }

bool Span::operator!=(const Span &other) const { return !(*this == other); }

bool Span::operator<(const Span &other) const
{
    if (lo != other.lo) {
        return lo < other.lo;
    }
    if (hi != other.hi) {
        return hi < other.hi;
    }
    return true;
}

bool Span::operator>(const Span &other) const { return other < *this; }

bool Span::operator<=(const Span &other) const { return !(other < *this); }

bool Span::operator>=(const Span &other) const { return !(*this < other); }
File span.h:

#pragma once

#include <cstddef>
#include <string>
#include <vector>
#include <memory>

struct SyntaxContextData {
    std::vector<std::string> macroStack;

    void pushMacro(const std::string &macroName);

    void popMacro();

    std::string currentMacro() const;
};

struct Span {
    Span() : lo(0), hi(0), context(nullptr) {};
    Span(std::size_t start, std::size_t end, const std::shared_ptr<SyntaxContextData> &ctxt)
        : lo(start), hi(end), context(ctxt) {};

    bool contains(std::size_t pos) const;
    bool overlaps(const Span &other) const;

    static Span merge(const Span &first, const Span &second);

    bool operator==(const Span &other) const;
    bool operator!=(const Span &other) const;
    bool operator<(const Span &other) const;
    bool operator>(const Span &other) const;
    bool operator<=(const Span &other) const;
    bool operator>=(const Span &other) const;

    // absolute offsets in bytes from SourceMap
    // the range is [lo, hi) bytes
    std::size_t lo;
    std::size_t hi;

    std::shared_ptr<SyntaxContextData> context;
};
File symbol_table.cpp:

#include "symbol_table.h"
#include "token.h"
#include <iostream>

void SymbolTable::addSymbol(const std::shared_ptr<Symbol> &symbol) { symbols[symbol->token.lexeme] = symbol; }

// Returns nullptr when symbol is not found
std::shared_ptr<Symbol> SymbolTable::findSymbol(const Token &token)
{
    auto it = symbols.find(token.lexeme);
    if (it != symbols.end()) {
        return it->second;
    }
    return nullptr;
}

std::shared_ptr<Symbol> SymbolTable::findSymbol(const std::string &name)
{
    auto it = symbols.find(name);
    if (it != symbols.end()) {
        return it->second;
    }
    return nullptr;
}

void SymbolTable::printSymbols()
{
    std::cout << "Symbol Table:\n";
    for (const auto &[name, symbol] : symbols) {
        if (auto dataVariableSymbol = std::dynamic_pointer_cast<DataVariableSymbol>(symbol)) {
            std::cout << "Name: " << name << ", Type: " << "Data Variable" << "\n";
        } else if (auto equVariableSymbol = std::dynamic_pointer_cast<EquVariableSymbol>(symbol)) {
            std::cout << "Name: " << name << ", Type: " << "EQU Variable" << "\n";
        } else if (auto equalVariableSymbol = std::dynamic_pointer_cast<EqualVariableSymbol>(symbol)) {
            std::cout << "Name: " << name << ", Type: " << "`=` Variable" << "\n";
        } else if (auto labelSymbol = std::dynamic_pointer_cast<LabelSymbol>(symbol)) {
            std::cout << "Name: " << name << ", Type: " << "Label Variable" << "\n";
        } else if (auto structSymbol = std::dynamic_pointer_cast<StructSymbol>(symbol)) {
            std::cout << "Name: " << name << ", Type: " << "STRUC" << "\n";
            for (const auto &[field, variable] : structSymbol->namedFields) {
                std::cout << "  Field name: " << field << "\n";
            }
        } else if (auto procSymbol = std::dynamic_pointer_cast<ProcSymbol>(symbol)) {
            std::cout << "Name: " << name << ", Type: " << "PROC" << "\n";
        } else if (auto recordSymbol = std::dynamic_pointer_cast<RecordSymbol>(symbol)) {
            std::cout << "Name: " << name << ", Type: " << "RECORD" << "\n";
        } else if (auto recordFieldSymbol = std::dynamic_pointer_cast<RecordFieldSymbol>(symbol)) {
            std::cout << "Name: " << name << ", Type: " << "Record Field" << "\n";
        }
    }
}

File symbol_table.h:

#pragma once

#include <string>
#include <unordered_map>
#include <memory>

#include "token.h"
#include "ast.h"

struct Symbol {
    Token token{};
    bool wasDefined = false; // when it's defined, its value is evaluated, also avoid visiting ExpressionPtr twice
    // bool wasEvaluated = false; // when error happens
    virtual ~Symbol() = default;
};

struct LabelSymbol : public Symbol {
    LabelSymbol(Token token) { this->token = std::move(token); }
    int32_t value = -1;

    int32_t size = 4;
    int32_t sizeOf = 4;
    int32_t length = 1;
    int32_t lengthof = 1;
};

struct ProcSymbol : public Symbol {
    ProcSymbol(Token token) { this->token = std::move(token); }
    int32_t value = -1;

    int32_t size = 4;
    int32_t sizeOf = 4;
    int32_t length = 1;
    int32_t lengthof = 1;
};

struct DataVariableSymbol : public Symbol {
    DataVariableSymbol(Token token, Token dataType) : dataType(std::move(dataType)) { this->token = std::move(token); }
    Token dataType;
    OperandSize dataTypeSize = OperandSize("", -1);
    int32_t value = -1;

    int32_t size = -1;
    int32_t sizeOf = -1;
    int32_t length = -1;
    int32_t lengthof = -1;
};

struct EquVariableSymbol : public Symbol {
    EquVariableSymbol(Token token, std::shared_ptr<EquDir> equDir) : equDir(std::move(equDir)) { this->token = std::move(token); }
    std::shared_ptr<EquDir> equDir;
    int32_t value = -1;

    int32_t size = 4;
    int32_t sizeOf = 4;
    int32_t length = 1;
    int32_t lengthof = 1;
};

struct EqualVariableSymbol : public Symbol {
    EqualVariableSymbol(Token token, std::shared_ptr<EqualDir> equalDir) : equalDir(std::move(equalDir)) { this->token = std::move(token); }
    std::shared_ptr<EqualDir> equalDir;
    int32_t value = -1;

    int32_t size = 4;
    int32_t sizeOf = 4;
    int32_t length = 1;
    int32_t lengthof = 1;
};

struct StructSymbol : public Symbol {
    StructSymbol(Token token) { this->token = std::move(token); }
    std::shared_ptr<StructDir> structDir;
    std::unordered_map<std::string, std::shared_ptr<DataVariableSymbol>> namedFields;

    int32_t size = -1;
    int32_t sizeOf = -1;
    // length and length of are not allowed
};

struct RecordSymbol : public Symbol {
    RecordSymbol(Token token, std::shared_ptr<RecordDir> recordDir) : recordDir(std::move(recordDir)) { this->token = std::move(token); }
    std::vector<std::string> fields;
    std::shared_ptr<RecordDir> recordDir;

    int32_t width = -1;
    int32_t mask = -1;

    int32_t size = 4;
    int32_t sizeOf = 4;
    // length and length of are not allowed
};

struct RecordFieldSymbol : public Symbol {
    RecordFieldSymbol(Token token, std::shared_ptr<RecordField> recordField) : recordField(std::move(recordField)) { this->token = std::move(token); }
    std::shared_ptr<RecordField> recordField;

    int32_t width = -1;
    std::optional<int32_t> initial;
    int32_t shift = -1;
    int32_t mask = -1;

    // size, sizeof, length, lengthof are not allowed
};

class SymbolTable {
public:
    void addSymbol(const std::shared_ptr<Symbol> &symbol);
    std::shared_ptr<Symbol> findSymbol(const Token &token);
    std::shared_ptr<Symbol> findSymbol(const std::string &name);
    void printSymbols();

private:
    std::unordered_map<std::string, std::shared_ptr<Symbol>> symbols;
};
File timer.h:

#pragma once

#include <chrono>
#include <iostream>
#include <string>

class Timer {
public:
    Timer() { reset(); }

    void reset() { m_start = std::chrono::high_resolution_clock::now(); }

    float elapsed()
    {
        return static_cast<float>(std::chrono::duration_cast<std::chrono::nanoseconds>(
                                      std::chrono::high_resolution_clock::now() - m_start)
                                      .count()) *
               0.001f * 0.001f * 0.001f;
    }

    float elapsed_millis() { return elapsed() * 1000.0f; }

private:
    std::chrono::time_point<std::chrono::high_resolution_clock> m_start;
};

// class ScopedTimer
// {
// public:
//     explicit ScopedTimer(const std::string &name) : m_name(name) {}
//     ~ScopedTimer() // NOLINT(cppcoreguidelines-special-member-functions): not using heap allocated memory here
//     {
//         const float time = m_timer.elapsed_millis();
//          LOG
//     }

// private:
//     std::string m_name;
//     Timer m_timer;
// };
File token.h:

#pragma once

#include <string>
#include <algorithm>
#include "span.h"

enum class TokenType : uint8_t {
    Identifier,
    Directive,
    Instruction,
    Type,
    Register,
    Number,
    StringLiteral,
    Operator,
    OpenBracket,        // '('
    CloseBracket,       // ')'
    OpenSquareBracket,  // '['
    CloseSquareBracket, // ']'
    OpenAngleBracket,   // '<'
    CloseAngleBracket,  // '>'
    Comma,              // ','
    Colon,              // ':'
    Dollar,             // '$'
    QuestionMark,       // '?'
    EndOfFile,
    EndOfLine,
    Comment,
    Invalid
};

struct Token {
    enum TokenType type;
    std::string lexeme;
    Span span;
    bool operator<(const Token &other) const
    {
        if (span.lo != other.span.lo) {
            return span.lo < other.span.lo;
        }
        return span.hi < other.span.hi;
    }
};

inline std::string stringToUpper(const std::string &str)
{
    std::string upperStr = str;
    std::transform(upperStr.begin(), upperStr.end(), upperStr.begin(),
                   [](unsigned char c) { return static_cast<char>(std::toupper(c)); });
    return upperStr;
}

inline bool isReservedWord(const Token &token)
{
    return token.lexeme.size() != 1 && token.type != TokenType::Number && token.type != TokenType::StringLiteral &&
           token.type != TokenType::Identifier && token.type != TokenType::EndOfLine &&
           token.type != TokenType::EndOfFile;
}

File tokenize.cpp:

#include "tokenize.h"
#include "diagnostic.h"
#include "session.h"
#include "log.h"
#include "error_codes.h"

#include <cctype>
#include <algorithm>
#include <unordered_set>
#include <string>

static const std::unordered_set<std::string> directives = {"=",      ".CODE", ".DATA", ".STACK", "DB",     "DW",     "DD",    "DQ",     "ELSE",
                                                           "ELSEIF", "END",   "ENDIF", "ENDM",   "ENDP",   "ENDS",   "EQU",   "FOR",    "FORC",
                                                           "IF",     "IFE",   "IFB",   "IFNB",   "IFDIF",  "IFDIFI", "IFIDN", "IFIDNI", "LOCAL",
                                                           "MACRO",  "PROC",  "STRUC", "RECORD", "REPEAT", "INCLUDE"};

static const std::unordered_set<std::string> reservedWords = {"DUP"};

// delete DUP from here?
static const std::unordered_set<std::string> operators = {"+",    "-",    "*",      "/",      ".",        "MOD",   "SHL",  "SHR",    "PTR",
                                                          "TYPE", "SIZE", "SIZEOF", "LENGTH", "LENGTHOF", "WIDTH", "MASK", "OFFSET", "DUP"};

static const std::unordered_set<std::string> types = {"BYTE", "WORD", "DWORD", "QWORD"};

static const std::unordered_set<std::string> instructions = {
    "ADC",   "ADD",   "AND", "CALL",  "CBW",  "CDQ", "CMP",    "CWD",   "DEC",  "DIV",    "IDIV", "IMUL",   "INC",     "JA",     "JAE",  "JB",
    "JBE",   "JC",    "JE",  "JECXZ", "JG",   "JGE", "JL",     "JLE",   "JMP",  "JNC",    "JNE",  "JNZ",    "JZ",      "LEA",    "LOOP", "MOV",
    "MOVSX", "MOVZX", "MUL", "NEG",   "NOT",  "OR",  "POP",    "POPFD", "PUSH", "PUSHFD", "RCL",  "RCR",    "RET",     "ROL",    "ROR",  "SBB",
    "SHL",   "SHR",   "SUB", "TEST",  "XCHG", "XOR", "INCHAR", "ININT", "EXIT", "OUTI",   "OUTU", "OUTSTR", "OUTCHAR", "NEWLINE"};

static const std::unordered_set<std::string> registers = {"AL", "AX",  "EAX", "BL",  "BX", "EBX", "CL", "CX",  "ECX", "DL",
                                                          "DX", "EDX", "SI",  "ESI", "DI", "EDI", "BP", "EBP", "SP",  "ESP"};

std::vector<Token> Tokenizer::tokenize()
{
    size_t length = src.size();

    while (pos < length) {
        skipWhitespace();

        if (pos >= length) {
            break;
        }

        if (src[pos] == '\n') {
            tokens.emplace_back(Token{TokenType::EndOfLine, "", Span(pos, pos + 1, nullptr)});
            ++pos;
            continue; // Skip calling getNextToken() after processing '\n'
        }

        Token token = getNextToken();
        // if (token.type == TokenType::Invalid) {
        //     // Stop tokenizing on error
        //     break;
        // }
        if (token.type != TokenType::Comment) {
            tokens.push_back(token);
        }
    }

    // because files always ends with a '\n', we can make EndOfFile span equal to the last '\n'
    // to be able to underline EndOfFile correctly
    tokens.emplace_back(Token{TokenType::EndOfFile, "", Span(pos - 1, pos, nullptr)});

    // TODO: remove testing code
    // Diagnostic diag(Diagnostic::Level::Error, ErrorCode::INVALID_NUMBER_FORMAT);
    // diag.addSecondaryLabel(Span(0, 1, nullptr), "pr");
    // diag.addPrimaryLabel(Span(2, 3, nullptr), "hey");
    // diag.addSecondaryLabel(Span(4, 5, nullptr), "hi");
    // diag.addPrimaryLabel(Span(pos - 1, pos, nullptr), "nice");
    // psess->dcx->addDiagnostic(diag);

    return tokens;
}

void Tokenizer::skipWhitespace()
{
    while (pos < src.size() && std::isspace(static_cast<unsigned char>(src[pos])) && src[pos] != '\n') {
        ++pos;
    }
}

Token Tokenizer::getNextToken()
{
    char currentChar = src[pos];

    if (isValidNumberStart(currentChar)) {
        return getNumberToken();
    } else if (isValidIdentifierStart(currentChar) || (currentChar == '.' && isDotName())) {
        return getIdentifierOrKeywordToken();
    } else if (currentChar == '"' || currentChar == '\'') {
        return getStringLiteralToken();
    } else if (currentChar == '\\') {
        // Line continuations are not handled; report an error
        size_t errorStart = pos;
        ++pos;
        addDiagnostic(errorStart, pos, ErrorCode::LINE_CONTINUATION_NOT_SUPPORTED);
        return Token{TokenType::Invalid, "\\", Span(errorStart, pos, nullptr)};
    } else if (currentChar == ';') {
        size_t commentStart = pos;
        while (pos < src.size() && src[pos] != '\n') {
            ++pos;
        }
        std::string commentText = src.substr(commentStart, pos - commentStart);
        return Token{TokenType::Comment, commentText, Span(commentStart, pos, nullptr)};
    } else {
        return getSpecialSymbolToken();
    }
}

bool Tokenizer::isDotName()
{
    if (pos + 1 >= src.size()) {
        return false;
    }

    size_t newPos = pos + 1;
    while (newPos < src.size() && isValidIdentifierChar(src[newPos])) {
        ++newPos;
    }

    std::string lexeme = src.substr(pos, newPos - pos);
    std::string lexemeUpper = stringToUpper(lexeme);
    return directives.contains(lexemeUpper);

    // char nextChar = src[pos + 1];

    // if (!isValidIdentifierChar(nextChar))
    //     return false;

    // // Check previous token
    // if (tokens.empty()) {
    //     // No previous token, accept the dotted name
    //     return true;
    // }

    // TokenType prevType = tokens.back().type;
    // std::string prevLexeme = tokens.back().lexeme;

    // if (prevType == TokenType::Register || prevType == TokenType::Identifier || prevLexeme == ")" ||
    //     prevLexeme == "]") {
    //     // Previous token is a register, identifier, or closing bracket; dot is an operator
    //     return false;
    // }

    // return true;
}

bool Tokenizer::isValidNumberStart(char c) { return isdigit(static_cast<unsigned char>(c)) || (tolower(c) >= 'a' && tolower(c) <= 'f'); }

Token Tokenizer::getIdentifierOrKeywordToken()
{
    size_t start = pos;

    // Handle optional starting dot
    if (src[pos] == '.') {
        ++pos;
    }

    while (pos < src.size() && isValidIdentifierChar(src[pos])) {
        ++pos;
    }

    std::string lexeme = src.substr(start, pos - start);
    std::string lexemeUpper = stringToUpper(lexeme);

    Span tokenSpan(start, pos, nullptr);

    if (directives.contains(lexemeUpper)) {
        return Token{TokenType::Directive, lexeme, tokenSpan};
    } else if (instructions.contains(lexemeUpper)) {
        return Token{TokenType::Instruction, lexeme, tokenSpan};
    } else if (registers.contains(lexemeUpper)) {
        return Token{TokenType::Register, lexeme, tokenSpan};
    } else if (operators.contains(lexemeUpper)) {
        return Token{TokenType::Operator, lexeme, tokenSpan};
    } else if (types.contains(lexemeUpper)) {
        return Token{TokenType::Type, lexeme, tokenSpan};
    } else {
        return Token{TokenType::Identifier, lexeme, tokenSpan};
    }
}

Token Tokenizer::getNumberToken()
{
    size_t start = pos;
    size_t length = src.size();

    // Collect alphanumeric characters until whitespace or operator
    while (pos < length && isalnum(static_cast<unsigned char>(src[pos]))) {
        ++pos;
    }
    std::string lexeme = src.substr(start, pos - start);

    // Now check if the lexeme is a valid number
    if (isValidNumber(lexeme)) {
        return Token{TokenType::Number, lexeme, Span(start, pos, nullptr)};
    } else {
        // check in cases like fffrh
        if (isValidIdentifier(lexeme)) {
            pos = start;
            return getIdentifierOrKeywordToken();
        }
        addDiagnostic(start, pos, ErrorCode::INVALID_NUMBER_FORMAT);
        return Token{TokenType::Invalid, lexeme, Span(start, pos, nullptr)};
    }
}

bool Tokenizer::isValidNumber(const std::string &lexeme)
{
    if (lexeme.empty()) {
        return false;
    }

    size_t len = lexeme.size();
    char suffix = static_cast<char>(tolower(lexeme[len - 1]));
    std::string digits = lexeme.substr(0, len - 1);
    unsigned int base = 10;

    // Determine base from suffix
    switch (suffix) {
    case 'h':
        base = 16;
        break;
    case 'b':
    case 'y':
        base = 2;
        break;
    case 'o':
    case 'q':
        base = 8;
        break;
    case 'd':
    case 't':
        base = 10;
        break;
    default:
        // No valid suffix; include the last character
        digits = lexeme;
        break;
    }

    // check that digits are valid for the base
    if (digits.empty()) {
        return false;
    }
    for (char c : digits) {
        c = static_cast<char>(tolower(c));
        if (base == 16) {
            if (!isxdigit(static_cast<unsigned char>(c))) {
                return false;
            }
        } else if (base == 10) {
            if (!isdigit(static_cast<unsigned char>(c))) {
                return false;
            }
        } else if (base == 8) {
            if (c < '0' || c > '7') {
                return false;
            }
        } else if (base == 2) {
            if (c != '0' && c != '1') {
                return false;
            }
        } else {
            return false; // Invalid base
        }
    }

    return true;
}

Token Tokenizer::getStringLiteralToken()
{
    char quoteChar = src[pos];
    size_t start = pos;
    ++pos; // skip the opening quote
    while (pos < src.size() && src[pos] != quoteChar) {
        if (src[pos] == '\n') {
            break;
        } else {
            ++pos;
        }
    }
    if (pos >= src.size() || src[pos] != quoteChar) {
        addDiagnostic(start, pos, ErrorCode::UNTERMINATED_STRING_LITERAL);
        return Token{TokenType::Invalid, src.substr(start, pos - start), Span(start, pos, nullptr)};
    }
    ++pos; // Skip the closing quote
    std::string lexeme = src.substr(start, pos - start);
    return Token{TokenType::StringLiteral, lexeme, Span(start, pos, nullptr)};
}

Token Tokenizer::getSpecialSymbolToken()
{
    size_t start = pos;
    char currentChar = src[pos];
    ++pos;

    std::string lexeme(1, currentChar);
    TokenType type = TokenType::Operator;

    switch (currentChar) {
    case '(':
        type = TokenType::OpenBracket;
        break;
    case ')':
        type = TokenType::CloseBracket;
        break;
    case '[':
        type = TokenType::OpenSquareBracket;
        break;
    case ']':
        type = TokenType::CloseSquareBracket;
        break;
    case ',':
        type = TokenType::Comma;
        break;
    case ':':
        type = TokenType::Colon;
        break;
    case '+':
    case '-':
    case '*':
    case '/':
    case '.':
        type = TokenType::Operator;
        break;
    case '=':
        type = TokenType::Directive;
        break;
    case '<':
        type = TokenType::OpenAngleBracket;
        break;
    case '>':
        type = TokenType::CloseAngleBracket;
        break;
    case '?':
        type = TokenType::QuestionMark;
        break;
    case '$':
        type = TokenType::Dollar;
        break;
    default:
        addDiagnostic(start, pos, ErrorCode::UNRECOGNIZED_SYMBOL);
        return Token{TokenType::Invalid, lexeme, Span(start, pos, nullptr)};
    }

    return Token{type, lexeme, Span(start, pos, nullptr)};
}

// TODO fix isalpha to handle utf8
bool Tokenizer::isValidIdentifierStart(char c) { return isalpha(c) || c == '_' || c == '@' || c == '$' || c == '?'; }

// TODO fix isalnum to handle utf8
bool Tokenizer::isValidIdentifierChar(char c) { return isalnum(c) || c == '_' || c == '@' || c == '$' || c == '?'; }

bool Tokenizer::isValidIdentifier(const std::string &lexeme)
{
    if (lexeme.empty()) {
        return false;
    }

    if (!isValidIdentifierStart(lexeme[0])) {
        return false;
    }

    for (size_t i = 1; i < lexeme.size(); ++i) {
        if (!isValidIdentifierChar(lexeme[i])) {
            return false;
        }
    }

    return true;
}
File tokenize.h:

#pragma once

#include "span.h"
#include "session.h"
#include "diagnostic.h"
#include "token.h"
#include <string>
#include <deque>
#include <unordered_set>


class Tokenizer {
public:
    Tokenizer(const std::shared_ptr<ParseSession> &psess, const std::string &src) : psess(psess), src(src) {}
    std::vector<Token> tokenize();

private:
    void skipWhitespace();
    Token getNextToken();
    Token getNumberToken();
    Token getIdentifierOrKeywordToken();
    Token getStringLiteralToken();
    Token getSpecialSymbolToken();
    bool isDotName();
    bool isValidNumber(const std::string &lexeme);
    bool isValidIdentifier(const std::string &lexeme);
    bool isValidIdentifierStart(char c);
    bool isValidIdentifierChar(char c);
    bool isValidNumberStart(char c);

    template <typename... Args> void addDiagnostic(size_t start, size_t end, ErrorCode errorCode, Args &&...args)
    {
        Diagnostic diag(Diagnostic::Level::Error, errorCode, std::forward<Args>(args)...);
        diag.addPrimaryLabel(Span(start, end, nullptr), "");
        psess->dcx->addDiagnostic(diag);
    }

    std::shared_ptr<ParseSession> psess;
    const std::string &src;
    std::size_t pos = 0;
    std::vector<Token> tokens;
};


File test_add.cpp:

#define DOCTEST_CONFIG_COLORS_ANSI
#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
#include <doctest/doctest.h>
#include "add.h"
#include "tokenize.h"
#include "session.h"
#include "diagnostic.h"
#include <memory>

// int add(int a, int b) { return a + b; }

TEST_CASE("testing the add function")
{
    CHECK(add(1, 2) == 3);
    CHECK(add(2, 5) == 7);
}

TEST_CASE("Tokenizer: Identifiers and Keywords")
{
    auto parseSess = std::make_shared<ParseSession>();

    SUBCASE("Valid Identifier")
    {
        std::string source = "myVar";
        Tokenizer tokenizer(parseSess, source);
        auto tokens = tokenizer.tokenize();

        CHECK(tokens.size() == 2); // Identifier + EndOfFile
        CHECK(tokens[0].type == TokenType::Identifier);
        CHECK(tokens[0].lexeme == "myVar");
    }

    SUBCASE("Directive Keyword")
    {
        std::string source = "EQU";
        Tokenizer tokenizer(parseSess, source);
        auto tokens = tokenizer.tokenize();

        CHECK(tokens[0].type == TokenType::Directive);
        CHECK(tokens[0].lexeme == "EQU");
    }

    SUBCASE("Instruction Keyword")
    {
        std::string source = "mov";
        Tokenizer tokenizer(parseSess, source);
        auto tokens = tokenizer.tokenize();

        CHECK(tokens[0].type == TokenType::Instruction);
        CHECK(tokens[0].lexeme == "mov");
    }

    SUBCASE("Register Keyword")
    {
        std::string source = "AX";
        Tokenizer tokenizer(parseSess, source);
        auto tokens = tokenizer.tokenize();

        CHECK(tokens[0].type == TokenType::Register);
        CHECK(tokens[0].lexeme == "AX");
    }

    SUBCASE("Identifier Starting with Dot")
    {
        std::string source = ".myLabel";
        Tokenizer tokenizer(parseSess, source);
        auto tokens = tokenizer.tokenize();

        CHECK(tokens[0].type == TokenType::Identifier);
        CHECK(tokens[0].lexeme == ".myLabel");
    }
}

// TEST_CASE("Tokenizer: Numbers") {
//     auto parseSess = std::make_shared<ParseSession>();

//     SUBCASE("Decimal Number") {
//         std::string source = "12345";
//         Tokenizer tokenizer(parseSess, source);
//         auto tokens = tokenizer.tokenize();

//         CHECK(tokens[0].type == TokenType::Number);
//         CHECK(tokens[0].lexeme == "12345");
//     }

//     SUBCASE("Hexadecimal Number with 'h' Suffix") {
//         std::string source = "0FFh";
//         Tokenizer tokenizer(parseSess, source);
//         auto tokens = tokenizer.tokenize();

//         CHECK(tokens[0].type == TokenType::Number);
//         CHECK(tokens[0].lexeme == "0FFh");
//     }

//     SUBCASE("Binary Number with 'b' Suffix") {
//         std::string source = "1010b";
//         Tokenizer tokenizer(parseSess, source);
//         auto tokens = tokenizer.tokenize();

//         CHECK(tokens[0].type == TokenType::Number);
//         CHECK(tokens[0].lexeme == "1010b");
//     }

//     SUBCASE("Octal Number with 'o' Suffix") {
//         std::string source = "77o";
//         Tokenizer tokenizer(parseSess, source);
//         auto tokens = tokenizer.tokenize();

//         CHECK(tokens[0].type == TokenType::Number);
//         CHECK(tokens[0].lexeme == "77o");
//     }

//     SUBCASE("Floating Point Number") {
//         std::string source = "3.14";
//         Tokenizer tokenizer(parseSess, source);
//         auto tokens = tokenizer.tokenize();

//         CHECK(tokens[0].type == TokenType::Number);
//         CHECK(tokens[0].lexeme == "3.14");
//     }

//     SUBCASE("Invalid Number Format") {
//         std::string source = "123XYZ";
//         Tokenizer tokenizer(parseSess, source);
//         auto tokens = tokenizer.tokenize();

//         CHECK(tokens[0].type == TokenType::Invalid);
//         CHECK(parseSess->dcx->hasErrors());
//     }
// }

// TEST_CASE("Tokenizer: Strings") {
//     auto parseSess = std::make_shared<ParseSession>();

//     SUBCASE("Double-Quoted String") {
//         std::string source = "\"Hello, World!\"";
//         Tokenizer tokenizer(parseSess, source);
//         auto tokens = tokenizer.tokenize();

//         CHECK(tokens[0].type == TokenType::StringLiteral);
//         CHECK(tokens[0].lexeme == "\"Hello, World!\"");
//     }

//     SUBCASE("Single-Quoted String") {
//         std::string source = "'Hello, MASM'";
//         Tokenizer tokenizer(parseSess, source);
//         auto tokens = tokenizer.tokenize();

//         CHECK(tokens[0].type == TokenType::StringLiteral);
//         CHECK(tokens[0].lexeme == "'Hello, MASM'");
//     }

//     SUBCASE("String with Escaped Quote") {
//         std::string source = "\"She said, \\\"Hello\\\"\"";
//         Tokenizer tokenizer(parseSess, source);
//         auto tokens = tokenizer.tokenize();

//         CHECK(tokens[0].type == TokenType::StringLiteral);
//         CHECK(tokens[0].lexeme == "\"She said, \\\"Hello\\\"\"");
//     }

//     SUBCASE("Unterminated String") {
//         std::string source = "\"This string is not closed";
//         Tokenizer tokenizer(parseSess, source);
//         auto tokens = tokenizer.tokenize();

//         CHECK(tokens[0].type == TokenType::Invalid);
//         CHECK(parseSess->dcx->hasErrors());
//     }
// }

// TEST_CASE("Tokenizer: Comments") {
//     auto parseSess = std::make_shared<ParseSession>();

//     SUBCASE("Single-Line Comment") {
//         std::string source = "; This is a comment";
//         Tokenizer tokenizer(parseSess, source);
//         auto tokens = tokenizer.tokenize();

//         CHECK(tokens[0].type == TokenType::Comment);
//         CHECK(tokens[0].lexeme == "; This is a comment");
//     }

//     SUBCASE("Code with Comment") {
//         std::string source = "MOV AX, BX ; Move BX into AX";
//         Tokenizer tokenizer(parseSess, source);
//         auto tokens = tokenizer.tokenize();

//         CHECK(tokens.size() == 7); // MOV, AX, ,, BX, Comment, EndOfFile
//         CHECK(tokens[0].type == TokenType::Instruction);
//         CHECK(tokens[0].lexeme == "MOV");
//         CHECK(tokens[5].type == TokenType::Comment);
//         CHECK(tokens[5].lexeme == "; Move BX into AX");
//     }
// }

// TEST_CASE("Tokenizer: Operators and Special Symbols") {
//     auto parseSess = std::make_shared<ParseSession>();

//     SUBCASE("Single-Character Operators") {
//         std::string source = "+ - * / % = < > & | ^ ~";
//         Tokenizer tokenizer(parseSess, source);
//         auto tokens = tokenizer.tokenize();

//         CHECK(tokens.size() == 14); // 12 operators + EndOfFile
//         CHECK(tokens[0].lexeme == "+");
//         CHECK(tokens[2].lexeme == "-");
//         CHECK(tokens[4].lexeme == "*");
//         CHECK(tokens[6].lexeme == "/");
//         // ... continue checking other operators
//     }

//     SUBCASE("Multi-Character Operators") {
//         std::string source = "== != <= >= && || ::";
//         Tokenizer tokenizer(parseSess, source);
//         auto tokens = tokenizer.tokenize();

//         CHECK(tokens.size() == 8); // 7 operators + EndOfFile
//         CHECK(tokens[0].lexeme == "==");
//         CHECK(tokens[1].lexeme == "!=");
//         CHECK(tokens[2].lexeme == "<=");
//         CHECK(tokens[3].lexeme == ">=");
//         CHECK(tokens[4].lexeme == "&&");
//         CHECK(tokens[5].lexeme == "||");
//         CHECK(tokens[6].lexeme == "::");
//     }

//     SUBCASE("Unrecognized Symbol") {
//         std::string source = "@";
//         Tokenizer tokenizer(parseSess, source);
//         auto tokens = tokenizer.tokenize();

//         // '@' can be part of identifiers in MASM, so it should be recognized
//         CHECK(tokens[0].type == TokenType::Identifier);
//         CHECK(tokens[0].lexeme == "@");
//     }
// }

// TEST_CASE("Tokenizer: Line Continuations") {
//     auto parseSess = std::make_shared<ParseSession>();

//     SUBCASE("Simple Line Continuation") {
//         std::string source = "MOV AX, \\\nBX";
//         Tokenizer tokenizer(parseSess, source);
//         auto tokens = tokenizer.tokenize();

//         CHECK(tokens.size() == 6); // MOV, AX, ,, BX, EndOfFile
//         CHECK(tokens[0].type == TokenType::Instruction);
//         CHECK(tokens[0].lexeme == "MOV");
//         CHECK(tokens[3].lexeme == "BX");
//     }

//     SUBCASE("Continuation with Comments") {
//         std::string source = "MOV AX, \\ ; continue\nBX";
//         Tokenizer tokenizer(parseSess, source);
//         auto tokens = tokenizer.tokenize();

//         CHECK(tokens.size() == 7); // MOV, AX, ,, BX, EndOfFile
//         CHECK(tokens[0].type == TokenType::Instruction);
//         CHECK(tokens[0].lexeme == "MOV");
//         CHECK(tokens[5].type == TokenType::Identifier);
//         CHECK(tokens[5].lexeme == "BX");
//     }
// }

// TEST_CASE("Tokenizer: Error Handling") {
//     auto parseSess = std::make_shared<ParseSession>();

//     SUBCASE("Unrecognized Character") {
//         std::string source = "#";
//         Tokenizer tokenizer(parseSess, source);
//         auto tokens = tokenizer.tokenize();

//         CHECK(tokens[0].type == TokenType::Invalid);
//         CHECK(parseSess->dcx->hasErrors());
//     }

//     SUBCASE("Recovery After Error") {
//         std::string source = "# MOV AX, BX";
//         Tokenizer tokenizer(parseSess, source);
//         auto tokens = tokenizer.tokenize();

//         // Should report error but continue tokenizing
//         CHECK(tokens[0].type == TokenType::Invalid);
//         CHECK(tokens[1].type == TokenType::Instruction);
//         CHECK(tokens[1].lexeme == "MOV");
//         CHECK(parseSess->dcx->hasErrors());
//     }
// }

